{"version":3,"file":"app.761a749c126b26b23bb9.hot-update.js","sources":["webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts"],"sourcesContent":["import angular from 'angular';\r\nimport _ from 'lodash';\r\nimport { InfluxQueryBuilder } from './query_builder';\r\nimport InfluxQuery from './influx_query';\r\nimport queryPart from './query_part';\r\nimport { QueryCtrl } from 'app/plugins/sdk';\r\nimport coreModule from 'app/core/core_module';\r\n\r\n\r\nexport class InfluxQueryCtrl extends QueryCtrl {\r\n  static templateUrl = 'partials/query.editor.html';\r\n\r\n  queryModel: InfluxQuery;\r\n  queryBuilder: any;\r\n  groupBySegment: any;\r\n  resultFormats: any[];\r\n  orderByTime: any[];\r\n  policySegment: any;\r\n  tagSegments: any[];\r\n  selectMenu: any;\r\n  measurementSegment: any;\r\n  removeTagFilterSegment: any;\r\n\r\n  /** @ngInject */\r\n  constructor($scope, $injector, private templateSrv, private $q, private uiSegmentSrv, private variableSrv) {\r\n    super($scope, $injector);\r\n    this.target = this.target;\r\n    this.queryModel = new InfluxQuery(this.target, templateSrv, this.panel.scopedVars);\r\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\r\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\r\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\r\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\r\n\r\n    if (!this.target.measurement) {\r\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\r\n    } else {\r\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\r\n    }\r\n\r\n    this.tagSegments = [];\r\n    for (const tag of this.target.tags) {\r\n      if (!tag.operator) {\r\n        if (/^\\/.*\\/$/.test(tag.value)) {\r\n          tag.operator = '=~';\r\n        } else {\r\n          tag.operator = '=';\r\n        }\r\n      }\r\n\r\n      if (tag.condition) {\r\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\r\n      }\r\n\r\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\r\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\r\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\r\n    }\r\n\r\n    this.fixTagSegments();\r\n    this.buildSelectMenu();\r\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\r\n      fake: true,\r\n      value: '-- remove tag filter --',\r\n    });\r\n  }\r\n\r\n  removeOrderByTime() {\r\n    this.target.orderByTime = 'ASC';\r\n  }\r\n\r\n  buildSelectMenu() {\r\n    const categories = queryPart.getCategories();\r\n    this.selectMenu = _.reduce(\r\n      categories,\r\n      (memo, cat, key) => {\r\n        const menu = {\r\n          text: key,\r\n          submenu: cat.map(item => {\r\n            return { text: item.type, value: item.type };\r\n          }),\r\n        };\r\n        memo.push(menu);\r\n        return memo;\r\n      },\r\n      []\r\n    );\r\n  }\r\n\r\n  getGroupByOptions() {\r\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then(tags => {\r\n        const options = [];\r\n        if (!this.queryModel.hasFill()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\r\n        }\r\n        if (!this.target.limit) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\r\n        }\r\n        if (!this.target.slimit) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\r\n        }\r\n        if (this.target.orderByTime === 'ASC') {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\r\n        }\r\n        if (!this.queryModel.hasGroupByTime()) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\r\n        }\r\n        for (const tag of tags) {\r\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\r\n        }\r\n        return options;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  groupByAction() {\r\n    switch (this.groupBySegment.value) {\r\n      case 'LIMIT': {\r\n        this.target.limit = 10;\r\n        break;\r\n      }\r\n      case 'SLIMIT': {\r\n        this.target.slimit = 10;\r\n        break;\r\n      }\r\n      case 'ORDER BY time DESC': {\r\n        this.target.orderByTime = 'DESC';\r\n        break;\r\n      }\r\n      default: {\r\n        this.queryModel.addGroupBy(this.groupBySegment.value);\r\n      }\r\n    }\r\n\r\n    const plusButton = this.uiSegmentSrv.newPlusButton();\r\n    this.groupBySegment.value = plusButton.value;\r\n    this.groupBySegment.html = plusButton.html;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  addSelectPart(selectParts, cat, subitem) {\r\n    this.queryModel.addSelectPart(selectParts, subitem.value);\r\n    this.panelCtrl.refresh();\r\n\tthis.getFields();\r\n  }\r\n\r\n  getFields(){\r\n\t  let variable;\r\n\t  \r\n\t  if(this.templateSrv.variableExists(\"$Sensor\")){\r\n\t\t \r\n\t\t  this.templateSrv.getVarFromIndex()[\"Sensor\"].query = \"eef, ref, wewewew222\";\r\n\t\t  console.log(this.templateSrv.getVarFromIndex()[\"Sensor\"]);\r\n\t\t  this.variableSrv.updateOptions(this.templateSrv.getVarFromIndex()[\"Sensor\"]);\r\n\t\t   console.log(222);\r\n\t  }else{\r\n\t\t  variable = this.variableSrv.createVariableFromModel( {type: \"custom\"} );\r\n\t\t  variable.name = \"Sensor\";\r\n\t\t  variable.query = \"eef, ref, wewewewew\";\r\n\t\t  this.variableSrv.updateOptions(variable);\r\n\t\t  this.variableSrv.addVariable(variable);\r\n\t  }\r\n\t\r\n\tconsole.log(444);\r\n\t\r\n\t//const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\r\n     //   return this.datasource\r\n      //    .metricFindQuery(fieldsQuery)\r\n  }\r\n  \r\n  handleSelectPartEvent(selectParts, part, evt) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\r\n        return this.datasource\r\n          .metricFindQuery(fieldsQuery)\r\n          .then(this.transformToSegments(true))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.queryModel.removeSelectPart(selectParts, part);\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleGroupByPartEvent(part, index, evt) {\r\n    switch (evt.name) {\r\n      case 'get-param-options': {\r\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n        return this.datasource\r\n          .metricFindQuery(tagsQuery)\r\n          .then(this.transformToSegments(true))\r\n          .catch(this.handleQueryError.bind(this));\r\n      }\r\n      case 'part-param-changed': {\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'action': {\r\n        this.queryModel.removeGroupByPart(part, index);\r\n        this.panelCtrl.refresh();\r\n        break;\r\n      }\r\n      case 'get-part-actions': {\r\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\r\n      }\r\n    }\r\n  }\r\n\r\n  fixTagSegments() {\r\n    const count = this.tagSegments.length;\r\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\r\n\r\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\r\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n    }\r\n  }\r\n\r\n  measurementChanged() {\r\n    this.target.measurement = this.measurementSegment.value;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  getPolicySegments() {\r\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\r\n    return this.datasource\r\n      .metricFindQuery(policiesQuery)\r\n      .then(this.transformToSegments(false))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  policyChanged() {\r\n    this.target.policy = this.policySegment.value;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  toggleEditorMode() {\r\n    try {\r\n      this.target.query = this.queryModel.render(false);\r\n    } catch (err) {\r\n      console.log('query render error');\r\n    }\r\n    this.target.rawQuery = !this.target.rawQuery;\r\n  }\r\n\r\n  getMeasurements(measurementFilter) {\r\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then(this.transformToSegments(true))\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  handleQueryError(err) {\r\n    this.error = err.message || 'Failed to issue metric query';\r\n    return [];\r\n  }\r\n\r\n  transformToSegments(addTemplateVars) {\r\n    return results => {\r\n      const segments = _.map(results, segment => {\r\n        return this.uiSegmentSrv.newSegment({\r\n          value: segment.text,\r\n          expandable: segment.expandable,\r\n        });\r\n      });\r\n\r\n      if (addTemplateVars) {\r\n        for (const variable of this.templateSrv.variables) {\r\n          segments.unshift(\r\n            this.uiSegmentSrv.newSegment({\r\n              type: 'value',\r\n              value: '/^$' + variable.name + '$/',\r\n              expandable: true,\r\n            })\r\n          );\r\n        }\r\n      }\r\n\r\n      return segments;\r\n    };\r\n  }\r\n\r\n  getTagsOrValues(segment, index) {\r\n    if (segment.type === 'condition') {\r\n      return this.$q.when([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\r\n    }\r\n    if (segment.type === 'operator') {\r\n      const nextValue = this.tagSegments[index + 1].value;\r\n      if (/^\\/.*\\/$/.test(nextValue)) {\r\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=~', '!~']));\r\n      } else {\r\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\r\n      }\r\n    }\r\n\r\n    let query, addTemplateVars;\r\n    if (segment.type === 'key' || segment.type === 'plus-button') {\r\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\r\n      addTemplateVars = false;\r\n    } else if (segment.type === 'value') {\r\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\r\n      addTemplateVars = true;\r\n    }\r\n\r\n    return this.datasource\r\n      .metricFindQuery(query)\r\n      .then(this.transformToSegments(addTemplateVars))\r\n      .then(results => {\r\n        if (segment.type === 'key') {\r\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\r\n        }\r\n        return results;\r\n      })\r\n      .catch(this.handleQueryError.bind(this));\r\n  }\r\n\r\n  getFieldSegments() {\r\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\r\n    return this.datasource\r\n      .metricFindQuery(fieldsQuery)\r\n      .then(this.transformToSegments(false))\r\n      .catch(this.handleQueryError);\r\n  }\r\n\r\n  tagSegmentUpdated(segment, index) {\r\n    this.tagSegments[index] = segment;\r\n\r\n    // handle remove tag condition\r\n    if (segment.value === this.removeTagFilterSegment.value) {\r\n      this.tagSegments.splice(index, 3);\r\n      if (this.tagSegments.length === 0) {\r\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n      } else if (this.tagSegments.length > 2) {\r\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\r\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\r\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n        }\r\n      }\r\n    } else {\r\n      if (segment.type === 'plus-button') {\r\n        if (index > 2) {\r\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\r\n        }\r\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\r\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\r\n        segment.type = 'key';\r\n        segment.cssClass = 'query-segment-key';\r\n      }\r\n\r\n      if (index + 1 === this.tagSegments.length) {\r\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\r\n      }\r\n    }\r\n\r\n    this.rebuildTargetTagConditions();\r\n  }\r\n\r\n  rebuildTargetTagConditions() {\r\n    const tags = [];\r\n    let tagIndex = 0;\r\n    let tagOperator = '';\r\n\r\n    _.each(this.tagSegments, (segment2, index) => {\r\n      if (segment2.type === 'key') {\r\n        if (tags.length === 0) {\r\n          tags.push({});\r\n        }\r\n        tags[tagIndex].key = segment2.value;\r\n      } else if (segment2.type === 'value') {\r\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\r\n        if (tagOperator) {\r\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\r\n          tags[tagIndex].operator = tagOperator;\r\n        }\r\n        tags[tagIndex].value = segment2.value;\r\n      } else if (segment2.type === 'condition') {\r\n        tags.push({ condition: segment2.value });\r\n        tagIndex += 1;\r\n      } else if (segment2.type === 'operator') {\r\n        tags[tagIndex].operator = segment2.value;\r\n      }\r\n    });\r\n\r\n    this.target.tags = tags;\r\n    this.panelCtrl.refresh();\r\n  }\r\n\r\n  getTagValueOperator(tagValue, tagOperator): string {\r\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\r\n      return '=~';\r\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\r\n      return '=';\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getCollapsedText() {\r\n    return this.queryModel.render(false);\r\n  }\r\n}\r\n\r\n\r\n\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAcA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAjZA;AAkZA;AAAA;AAnZA;;;;;A","sourceRoot":""}