{"version":3,"file":"explore.c2dcfadc09ea6a66474a.js","sources":["webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/core/utils/text.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/ElapsedTime.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Explore.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Graph.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Legend.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Logs.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/PromQueryField.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/QueryField.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/QueryRows.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Table.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/TimePicker.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Typeahead.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Value.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/Wrapper.tsx","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/slate-plugins/braces.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/slate-plugins/clear.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/slate-plugins/newline.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/slate-plugins/prism/promql.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/slate-plugins/runner.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/utils/dom.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/utils/prometheus.ts","webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///webpack:///./public/app/features/explore/utils/query.ts"],"sourcesContent":["import { TextMatch } from 'app/types/explore';\r\n\r\n/**\r\n * Adapt findMatchesInText for react-highlight-words findChunks handler.\r\n * See https://github.com/bvaughn/react-highlight-words#props\r\n */\r\nexport function findHighlightChunksInText({ searchWords, textToHighlight }) {\r\n  return findMatchesInText(textToHighlight, searchWords.join(' '));\r\n}\r\n\r\n/**\r\n * Returns a list of substring regexp matches.\r\n */\r\nexport function findMatchesInText(haystack: string, needle: string): TextMatch[] {\r\n  // Empty search can send re.exec() into infinite loop, exit early\r\n  if (!haystack || !needle) {\r\n    return [];\r\n  }\r\n  const regexp = new RegExp(`(?:${needle})`, 'g');\r\n  const matches = [];\r\n  let match = regexp.exec(haystack);\r\n  while (match) {\r\n    matches.push({\r\n      text: match[0],\r\n      start: match.index,\r\n      length: match[0].length,\r\n      end: match.index + match[0].length,\r\n    });\r\n    match = regexp.exec(haystack);\r\n  }\r\n  return matches;\r\n}\r\n","import React, { PureComponent } from 'react';\r\n\r\nconst INTERVAL = 150;\r\n\r\nexport default class ElapsedTime extends PureComponent<any, any> {\r\n  offset: number;\r\n  timer: number;\r\n\r\n  state = {\r\n    elapsed: 0,\r\n  };\r\n\r\n  start() {\r\n    this.offset = Date.now();\r\n    this.timer = window.setInterval(this.tick, INTERVAL);\r\n  }\r\n\r\n  tick = () => {\r\n    const jetzt = Date.now();\r\n    const elapsed = jetzt - this.offset;\r\n    this.setState({ elapsed });\r\n  };\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (nextProps.time) {\r\n      clearInterval(this.timer);\r\n    } else if (this.props.time) {\r\n      this.start();\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.start();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    clearInterval(this.timer);\r\n  }\r\n\r\n  render() {\r\n    const { elapsed } = this.state;\r\n    const { className, time } = this.props;\r\n    const value = (time || elapsed) / 1000;\r\n    return <span className={`elapsed-time ${className}`}>{value.toFixed(1)}s</span>;\r\n  }\r\n}\r\n","import React from 'react';\r\nimport { hot } from 'react-hot-loader';\r\nimport Select from 'react-select';\r\n\r\nimport { ExploreState, ExploreUrlState, Query } from 'app/types/explore';\r\nimport kbn from 'app/core/utils/kbn';\r\nimport colors from 'app/core/utils/colors';\r\nimport store from 'app/core/store';\r\nimport TimeSeries from 'app/core/time_series2';\r\nimport { parse as parseDate } from 'app/core/utils/datemath';\r\nimport { DEFAULT_RANGE } from 'app/core/utils/explore';\r\nimport ResetStyles from 'app/core/components/Picker/ResetStyles';\r\nimport PickerOption from 'app/core/components/Picker/PickerOption';\r\nimport IndicatorsContainer from 'app/core/components/Picker/IndicatorsContainer';\r\nimport NoOptionsMessage from 'app/core/components/Picker/NoOptionsMessage';\r\n\r\nimport ElapsedTime from './ElapsedTime';\r\nimport QueryRows from './QueryRows';\r\nimport Graph from './Graph';\r\nimport Logs from './Logs';\r\nimport Table from './Table';\r\nimport TimePicker from './TimePicker';\r\nimport { ensureQueries, generateQueryKey, hasQuery } from './utils/query';\r\n\r\nconst MAX_HISTORY_ITEMS = 100;\r\n\r\nfunction makeHints(hints) {\r\n  const hintsByIndex = [];\r\n  hints.forEach(hint => {\r\n    if (hint) {\r\n      hintsByIndex[hint.index] = hint;\r\n    }\r\n  });\r\n  return hintsByIndex;\r\n}\r\n\r\nfunction makeTimeSeriesList(dataList, options) {\r\n  return dataList.map((seriesData, index) => {\r\n    const datapoints = seriesData.datapoints || [];\r\n    const alias = seriesData.target;\r\n    const colorIndex = index % colors.length;\r\n    const color = colors[colorIndex];\r\n\r\n    const series = new TimeSeries({\r\n      datapoints,\r\n      alias,\r\n      color,\r\n      unit: seriesData.unit,\r\n    });\r\n\r\n    return series;\r\n  });\r\n}\r\n\r\ninterface ExploreProps {\r\n  datasourceSrv: any;\r\n  onChangeSplit: (split: boolean, state?: ExploreState) => void;\r\n  onSaveState: (key: string, state: ExploreState) => void;\r\n  position: string;\r\n  split: boolean;\r\n  splitState?: ExploreState;\r\n  stateKey: string;\r\n  urlState: ExploreUrlState;\r\n}\r\n\r\nexport class Explore extends React.PureComponent<ExploreProps, ExploreState> {\r\n  el: any;\r\n  /**\r\n   * Current query expressions of the rows including their modifications, used for running queries.\r\n   * Not kept in component state to prevent edit-render roundtrips.\r\n   */\r\n  queryExpressions: string[];\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    const splitState: ExploreState = props.splitState;\r\n    let initialQueries: Query[];\r\n    if (splitState) {\r\n      // Split state overrides everything\r\n      this.state = splitState;\r\n      initialQueries = splitState.queries;\r\n    } else {\r\n      const { datasource, queries, range } = props.urlState as ExploreUrlState;\r\n      initialQueries = ensureQueries(queries);\r\n      this.state = {\r\n        datasource: null,\r\n        datasourceError: null,\r\n        datasourceLoading: null,\r\n        datasourceMissing: false,\r\n        datasourceName: datasource,\r\n        exploreDatasources: [],\r\n        graphResult: null,\r\n        history: [],\r\n        latency: 0,\r\n        loading: false,\r\n        logsResult: null,\r\n        queries: initialQueries,\r\n        queryErrors: [],\r\n        queryHints: [],\r\n        range: range || { ...DEFAULT_RANGE },\r\n        requestOptions: null,\r\n        showingGraph: true,\r\n        showingLogs: true,\r\n        showingTable: true,\r\n        supportsGraph: null,\r\n        supportsLogs: null,\r\n        supportsTable: null,\r\n        tableResult: null,\r\n      };\r\n    }\r\n    this.queryExpressions = initialQueries.map(q => q.query);\r\n  }\r\n\r\n  async componentDidMount() {\r\n    const { datasourceSrv } = this.props;\r\n    const { datasourceName } = this.state;\r\n    if (!datasourceSrv) {\r\n      throw new Error('No datasource service passed as props.');\r\n    }\r\n    const datasources = datasourceSrv.getExploreSources();\r\n    const exploreDatasources = datasources.map(ds => ({\r\n      value: ds.name,\r\n      label: ds.name,\r\n    }));\r\n\r\n    if (datasources.length > 0) {\r\n      this.setState({ datasourceLoading: true, exploreDatasources });\r\n      // Priority: datasource in url, default datasource, first explore datasource\r\n      let datasource;\r\n      if (datasourceName) {\r\n        datasource = await datasourceSrv.get(datasourceName);\r\n      } else {\r\n        datasource = await datasourceSrv.get();\r\n      }\r\n      if (!datasource.meta.explore) {\r\n        datasource = await datasourceSrv.get(datasources[0].name);\r\n      }\r\n      await this.setDatasource(datasource);\r\n    } else {\r\n      this.setState({ datasourceMissing: true });\r\n    }\r\n  }\r\n\r\n  componentDidCatch(error) {\r\n    this.setState({ datasourceError: error });\r\n    console.error(error);\r\n  }\r\n\r\n  async setDatasource(datasource) {\r\n    const supportsGraph = datasource.meta.metrics;\r\n    const supportsLogs = datasource.meta.logs;\r\n    const supportsTable = datasource.meta.metrics;\r\n    const datasourceId = datasource.meta.id;\r\n    let datasourceError = null;\r\n\r\n    try {\r\n      const testResult = await datasource.testDatasource();\r\n      datasourceError = testResult.status === 'success' ? null : testResult.message;\r\n    } catch (error) {\r\n      datasourceError = (error && error.statusText) || error;\r\n    }\r\n\r\n    const historyKey = `grafana.explore.history.${datasourceId}`;\r\n    const history = store.getObject(historyKey, []);\r\n\r\n    if (datasource.init) {\r\n      datasource.init();\r\n    }\r\n\r\n    // Keep queries but reset edit state\r\n    const nextQueries = this.state.queries.map((q, i) => ({\r\n      ...q,\r\n      key: generateQueryKey(i),\r\n      query: this.queryExpressions[i],\r\n    }));\r\n\r\n    this.setState(\r\n      {\r\n        datasource,\r\n        datasourceError,\r\n        history,\r\n        supportsGraph,\r\n        supportsLogs,\r\n        supportsTable,\r\n        datasourceLoading: false,\r\n        datasourceName: datasource.name,\r\n        queries: nextQueries,\r\n      },\r\n      () => {\r\n        if (datasourceError === null) {\r\n          this.onSubmit();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  getRef = el => {\r\n    this.el = el;\r\n  };\r\n\r\n  onAddQueryRow = index => {\r\n    const { queries } = this.state;\r\n    this.queryExpressions[index + 1] = '';\r\n    const nextQueries = [\r\n      ...queries.slice(0, index + 1),\r\n      { query: '', key: generateQueryKey() },\r\n      ...queries.slice(index + 1),\r\n    ];\r\n    this.setState({ queries: nextQueries });\r\n  };\r\n\r\n  onChangeDatasource = async option => {\r\n    this.setState({\r\n      datasource: null,\r\n      datasourceError: null,\r\n      datasourceLoading: true,\r\n      graphResult: null,\r\n      latency: 0,\r\n      logsResult: null,\r\n      queryErrors: [],\r\n      queryHints: [],\r\n      tableResult: null,\r\n    });\r\n    const datasourceName = option.value;\r\n    const datasource = await this.props.datasourceSrv.get(datasourceName);\r\n    this.setDatasource(datasource);\r\n  };\r\n\r\n  onChangeQuery = (value: string, index: number, override?: boolean) => {\r\n    // Keep current value in local cache\r\n    this.queryExpressions[index] = value;\r\n\r\n    // Replace query row on override\r\n    if (override) {\r\n      const { queries } = this.state;\r\n      const nextQuery: Query = {\r\n        key: generateQueryKey(index),\r\n        query: value,\r\n      };\r\n      const nextQueries = [...queries];\r\n      nextQueries[index] = nextQuery;\r\n\r\n      this.setState(\r\n        {\r\n          queryErrors: [],\r\n          queryHints: [],\r\n          queries: nextQueries,\r\n        },\r\n        this.onSubmit\r\n      );\r\n    }\r\n  };\r\n\r\n  onChangeTime = nextRange => {\r\n    const range = {\r\n      from: nextRange.from,\r\n      to: nextRange.to,\r\n    };\r\n    this.setState({ range }, () => this.onSubmit());\r\n  };\r\n\r\n  onClickClear = () => {\r\n    this.queryExpressions = [''];\r\n    this.setState(\r\n      {\r\n        graphResult: null,\r\n        logsResult: null,\r\n        latency: 0,\r\n        queries: ensureQueries(),\r\n        queryErrors: [],\r\n        queryHints: [],\r\n        tableResult: null,\r\n      },\r\n      this.saveState\r\n    );\r\n  };\r\n\r\n  onClickCloseSplit = () => {\r\n    const { onChangeSplit } = this.props;\r\n    if (onChangeSplit) {\r\n      onChangeSplit(false);\r\n    }\r\n  };\r\n\r\n  onClickGraphButton = () => {\r\n    this.setState(state => ({ showingGraph: !state.showingGraph }));\r\n  };\r\n\r\n  onClickLogsButton = () => {\r\n    this.setState(state => ({ showingLogs: !state.showingLogs }));\r\n  };\r\n\r\n  onClickSplit = () => {\r\n    const { onChangeSplit } = this.props;\r\n    if (onChangeSplit) {\r\n      const state = this.cloneState();\r\n      onChangeSplit(true, state);\r\n    }\r\n  };\r\n\r\n  onClickTableButton = () => {\r\n    this.setState(state => ({ showingTable: !state.showingTable }));\r\n  };\r\n\r\n  onClickTableCell = (columnKey: string, rowValue: string) => {\r\n    this.onModifyQueries({ type: 'ADD_FILTER', key: columnKey, value: rowValue });\r\n  };\r\n\r\n  onModifyQueries = (action: object, index?: number) => {\r\n    const { datasource, queries } = this.state;\r\n    if (datasource && datasource.modifyQuery) {\r\n      let nextQueries;\r\n      if (index === undefined) {\r\n        // Modify all queries\r\n        nextQueries = queries.map((q, i) => ({\r\n          key: generateQueryKey(i),\r\n          query: datasource.modifyQuery(this.queryExpressions[i], action),\r\n        }));\r\n      } else {\r\n        // Modify query only at index\r\n        nextQueries = [\r\n          ...queries.slice(0, index),\r\n          {\r\n            key: generateQueryKey(index),\r\n            query: datasource.modifyQuery(this.queryExpressions[index], action),\r\n          },\r\n          ...queries.slice(index + 1),\r\n        ];\r\n      }\r\n      this.queryExpressions = nextQueries.map(q => q.query);\r\n      this.setState({ queries: nextQueries }, () => this.onSubmit());\r\n    }\r\n  };\r\n\r\n  onRemoveQueryRow = index => {\r\n    const { queries } = this.state;\r\n    if (queries.length <= 1) {\r\n      return;\r\n    }\r\n    const nextQueries = [...queries.slice(0, index), ...queries.slice(index + 1)];\r\n    this.queryExpressions = nextQueries.map(q => q.query);\r\n    this.setState({ queries: nextQueries }, () => this.onSubmit());\r\n  };\r\n\r\n  onSubmit = () => {\r\n    const { showingLogs, showingGraph, showingTable, supportsGraph, supportsLogs, supportsTable } = this.state;\r\n    if (showingTable && supportsTable) {\r\n      this.runTableQuery();\r\n    }\r\n    if (showingGraph && supportsGraph) {\r\n      this.runGraphQuery();\r\n    }\r\n    if (showingLogs && supportsLogs) {\r\n      this.runLogsQuery();\r\n    }\r\n    this.saveState();\r\n  };\r\n\r\n  onQuerySuccess(datasourceId: string, queries: string[]): void {\r\n    // save queries to history\r\n    let { history } = this.state;\r\n    const { datasource } = this.state;\r\n\r\n    if (datasource.meta.id !== datasourceId) {\r\n      // Navigated away, queries did not matter\r\n      return;\r\n    }\r\n\r\n    const ts = Date.now();\r\n    queries.forEach(query => {\r\n      history = [{ query, ts }, ...history];\r\n    });\r\n\r\n    if (history.length > MAX_HISTORY_ITEMS) {\r\n      history = history.slice(0, MAX_HISTORY_ITEMS);\r\n    }\r\n\r\n    // Combine all queries of a datasource type into one history\r\n    const historyKey = `grafana.explore.history.${datasourceId}`;\r\n    store.setObject(historyKey, history);\r\n    this.setState({ history });\r\n  }\r\n\r\n  buildQueryOptions(targetOptions: { format: string; hinting?: boolean; instant?: boolean }) {\r\n    const { datasource, range } = this.state;\r\n    const resolution = this.el.offsetWidth;\r\n    const absoluteRange = {\r\n      from: parseDate(range.from, false),\r\n      to: parseDate(range.to, true),\r\n    };\r\n    const { interval } = kbn.calculateInterval(absoluteRange, resolution, datasource.interval);\r\n    const targets = this.queryExpressions.map(q => ({\r\n      ...targetOptions,\r\n      expr: q,\r\n    }));\r\n    return {\r\n      interval,\r\n      range,\r\n      targets,\r\n    };\r\n  }\r\n\r\n  async runGraphQuery() {\r\n    const { datasource } = this.state;\r\n    const queries = [...this.queryExpressions];\r\n    if (!hasQuery(queries)) {\r\n      return;\r\n    }\r\n    this.setState({ latency: 0, loading: true, graphResult: null, queryErrors: [], queryHints: [] });\r\n    const now = Date.now();\r\n    const options = this.buildQueryOptions({ format: 'time_series', instant: false, hinting: true });\r\n    try {\r\n      const res = await datasource.query(options);\r\n      const result = makeTimeSeriesList(res.data, options);\r\n      const queryHints = res.hints ? makeHints(res.hints) : [];\r\n      const latency = Date.now() - now;\r\n      this.setState({ latency, loading: false, graphResult: result, queryHints, requestOptions: options });\r\n      this.onQuerySuccess(datasource.meta.id, queries);\r\n    } catch (response) {\r\n      console.error(response);\r\n      const queryError = response.data ? response.data.error : response;\r\n      this.setState({ loading: false, queryErrors: [queryError] });\r\n    }\r\n  }\r\n\r\n  async runTableQuery() {\r\n    const queries = [...this.queryExpressions];\r\n    const { datasource } = this.state;\r\n    if (!hasQuery(queries)) {\r\n      return;\r\n    }\r\n    this.setState({ latency: 0, loading: true, queryErrors: [], queryHints: [], tableResult: null });\r\n    const now = Date.now();\r\n    const options = this.buildQueryOptions({\r\n      format: 'table',\r\n      instant: true,\r\n    });\r\n    try {\r\n      const res = await datasource.query(options);\r\n      const tableModel = res.data[0];\r\n      const latency = Date.now() - now;\r\n      this.setState({ latency, loading: false, tableResult: tableModel, requestOptions: options });\r\n      this.onQuerySuccess(datasource.meta.id, queries);\r\n    } catch (response) {\r\n      console.error(response);\r\n      const queryError = response.data ? response.data.error : response;\r\n      this.setState({ loading: false, queryErrors: [queryError] });\r\n    }\r\n  }\r\n\r\n  async runLogsQuery() {\r\n    const queries = [...this.queryExpressions];\r\n    const { datasource } = this.state;\r\n    if (!hasQuery(queries)) {\r\n      return;\r\n    }\r\n    this.setState({ latency: 0, loading: true, queryErrors: [], queryHints: [], logsResult: null });\r\n    const now = Date.now();\r\n    const options = this.buildQueryOptions({\r\n      format: 'logs',\r\n    });\r\n\r\n    try {\r\n      const res = await datasource.query(options);\r\n      const logsData = res.data;\r\n      const latency = Date.now() - now;\r\n      this.setState({ latency, loading: false, logsResult: logsData, requestOptions: options });\r\n      this.onQuerySuccess(datasource.meta.id, queries);\r\n    } catch (response) {\r\n      console.error(response);\r\n      const queryError = response.data ? response.data.error : response;\r\n      this.setState({ loading: false, queryErrors: [queryError] });\r\n    }\r\n  }\r\n\r\n  request = url => {\r\n    const { datasource } = this.state;\r\n    return datasource.metadataRequest(url);\r\n  };\r\n\r\n  cloneState(): ExploreState {\r\n    // Copy state, but copy queries including modifications\r\n    return {\r\n      ...this.state,\r\n      queries: ensureQueries(this.queryExpressions.map(query => ({ query }))),\r\n    };\r\n  }\r\n\r\n  saveState = () => {\r\n    const { stateKey, onSaveState } = this.props;\r\n    onSaveState(stateKey, this.cloneState());\r\n  };\r\n\r\n  render() {\r\n    const { position, split } = this.props;\r\n    const {\r\n      datasource,\r\n      datasourceError,\r\n      datasourceLoading,\r\n      datasourceMissing,\r\n      exploreDatasources,\r\n      graphResult,\r\n      history,\r\n      latency,\r\n      loading,\r\n      logsResult,\r\n      queries,\r\n      queryErrors,\r\n      queryHints,\r\n      range,\r\n      requestOptions,\r\n      showingGraph,\r\n      showingLogs,\r\n      showingTable,\r\n      supportsGraph,\r\n      supportsLogs,\r\n      supportsTable,\r\n      tableResult,\r\n    } = this.state;\r\n    const showingBoth = showingGraph && showingTable;\r\n    const graphHeight = showingBoth ? '200px' : '400px';\r\n    const graphButtonActive = showingBoth || showingGraph ? 'active' : '';\r\n    const logsButtonActive = showingLogs ? 'active' : '';\r\n    const tableButtonActive = showingBoth || showingTable ? 'active' : '';\r\n    const exploreClass = split ? 'explore explore-split' : 'explore';\r\n    const selectedDatasource = datasource ? exploreDatasources.find(d => d.label === datasource.name) : undefined;\r\n\r\n    return (\r\n      <div className={exploreClass} ref={this.getRef}>\r\n        <div className=\"navbar\">\r\n          {position === 'left' ? (\r\n            <div>\r\n              <a className=\"navbar-page-btn\">\r\n                <i className=\"fa fa-rocket\" />\r\n                Explore\r\n              </a>\r\n            </div>\r\n          ) : (\r\n            <div className=\"navbar-buttons explore-first-button\">\r\n              <button className=\"btn navbar-button\" onClick={this.onClickCloseSplit}>\r\n                Close Split\r\n              </button>\r\n            </div>\r\n          )}\r\n          {!datasourceMissing ? (\r\n            <div className=\"navbar-buttons\">\r\n              <Select\r\n                classNamePrefix={`gf-form-select-box`}\r\n                isMulti={false}\r\n                isLoading={datasourceLoading}\r\n                isClearable={false}\r\n                className=\"gf-form-input gf-form-input--form-dropdown datasource-picker\"\r\n                onChange={this.onChangeDatasource}\r\n                options={exploreDatasources}\r\n                styles={ResetStyles}\r\n                placeholder=\"Select datasource\"\r\n                loadingMessage={() => 'Loading datasources...'}\r\n                noOptionsMessage={() => 'No datasources found'}\r\n                value={selectedDatasource}\r\n                components={{\r\n                  Option: PickerOption,\r\n                  IndicatorsContainer,\r\n                  NoOptionsMessage,\r\n                }}\r\n              />\r\n            </div>\r\n          ) : null}\r\n          <div className=\"navbar__spacer\" />\r\n          {position === 'left' && !split ? (\r\n            <div className=\"navbar-buttons\">\r\n              <button className=\"btn navbar-button\" onClick={this.onClickSplit}>\r\n                Split\r\n              </button>\r\n            </div>\r\n          ) : null}\r\n          <TimePicker range={range} onChangeTime={this.onChangeTime} />\r\n          <div className=\"navbar-buttons\">\r\n            <button className=\"btn navbar-button navbar-button--no-icon\" onClick={this.onClickClear}>\r\n              Clear All\r\n            </button>\r\n          </div>\r\n          <div className=\"navbar-buttons relative\">\r\n            <button className=\"btn navbar-button--primary\" onClick={this.onSubmit}>\r\n              Run Query <i className=\"fa fa-level-down run-icon\" />\r\n            </button>\r\n            {loading || latency ? <ElapsedTime time={latency} className=\"text-info\" /> : null}\r\n          </div>\r\n        </div>\r\n\r\n        {datasourceLoading ? <div className=\"explore-container\">Loading datasource...</div> : null}\r\n\r\n        {datasourceMissing ? (\r\n          <div className=\"explore-container\">Please add a datasource that supports Explore (e.g., Prometheus).</div>\r\n        ) : null}\r\n\r\n        {datasourceError ? (\r\n          <div className=\"explore-container\">Error connecting to datasource. [{datasourceError}]</div>\r\n        ) : null}\r\n\r\n        {datasource && !datasourceError ? (\r\n          <div className=\"explore-container\">\r\n            <QueryRows\r\n              history={history}\r\n              queries={queries}\r\n              queryErrors={queryErrors}\r\n              queryHints={queryHints}\r\n              request={this.request}\r\n              onAddQueryRow={this.onAddQueryRow}\r\n              onChangeQuery={this.onChangeQuery}\r\n              onClickHintFix={this.onModifyQueries}\r\n              onExecuteQuery={this.onSubmit}\r\n              onRemoveQueryRow={this.onRemoveQueryRow}\r\n              supportsLogs={supportsLogs}\r\n            />\r\n            <div className=\"result-options\">\r\n              {supportsGraph ? (\r\n                <button className={`btn toggle-btn ${graphButtonActive}`} onClick={this.onClickGraphButton}>\r\n                  Graph\r\n                </button>\r\n              ) : null}\r\n              {supportsTable ? (\r\n                <button className={`btn toggle-btn ${tableButtonActive}`} onClick={this.onClickTableButton}>\r\n                  Table\r\n                </button>\r\n              ) : null}\r\n              {supportsLogs ? (\r\n                <button className={`btn toggle-btn ${logsButtonActive}`} onClick={this.onClickLogsButton}>\r\n                  Logs\r\n                </button>\r\n              ) : null}\r\n            </div>\r\n\r\n            <main className=\"m-t-2\">\r\n              {supportsGraph &&\r\n                showingGraph &&\r\n                graphResult && (\r\n                  <Graph\r\n                    data={graphResult}\r\n                    height={graphHeight}\r\n                    loading={loading}\r\n                    id={`explore-graph-${position}`}\r\n                    options={requestOptions}\r\n                    split={split}\r\n                  />\r\n                )}\r\n              {supportsTable && showingTable ? (\r\n                <div className=\"panel-container\">\r\n                  <Table data={tableResult} loading={loading} onClickCell={this.onClickTableCell} />\r\n                </div>\r\n              ) : null}\r\n              {supportsLogs && showingLogs ? <Logs data={logsResult} loading={loading} /> : null}\r\n            </main>\r\n          </div>\r\n        ) : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default hot(module)(Explore);\r\n","import $ from 'jquery';\r\nimport React, { PureComponent } from 'react';\r\nimport moment from 'moment';\r\nimport { withSize } from 'react-sizeme';\r\n\r\nimport 'vendor/flot/jquery.flot';\r\nimport 'vendor/flot/jquery.flot.time';\r\nimport * as dateMath from 'app/core/utils/datemath';\r\nimport TimeSeries from 'app/core/time_series2';\r\n\r\nimport Legend from './Legend';\r\n\r\nconst MAX_NUMBER_OF_TIME_SERIES = 20;\r\n\r\n// Copied from graph.ts\r\nfunction time_format(ticks, min, max) {\r\n  if (min && max && ticks) {\r\n    const range = max - min;\r\n    const secPerTick = range / ticks / 1000;\r\n    const oneDay = 86400000;\r\n    const oneYear = 31536000000;\r\n\r\n    if (secPerTick <= 45) {\r\n      return '%H:%M:%S';\r\n    }\r\n    if (secPerTick <= 7200 || range <= oneDay) {\r\n      return '%H:%M';\r\n    }\r\n    if (secPerTick <= 80000) {\r\n      return '%m/%d %H:%M';\r\n    }\r\n    if (secPerTick <= 2419200 || range <= oneYear) {\r\n      return '%m/%d';\r\n    }\r\n    return '%Y-%m';\r\n  }\r\n\r\n  return '%H:%M';\r\n}\r\n\r\nconst FLOT_OPTIONS = {\r\n  legend: {\r\n    show: false,\r\n  },\r\n  series: {\r\n    lines: {\r\n      linewidth: 1,\r\n      zero: false,\r\n    },\r\n    shadowSize: 0,\r\n  },\r\n  grid: {\r\n    minBorderMargin: 0,\r\n    markings: [],\r\n    backgroundColor: null,\r\n    borderWidth: 0,\r\n    // hoverable: true,\r\n    clickable: true,\r\n    color: '#a1a1a1',\r\n    margin: { left: 0, right: 0 },\r\n    labelMarginX: 0,\r\n  },\r\n  // selection: {\r\n  //   mode: 'x',\r\n  //   color: '#666',\r\n  // },\r\n  // crosshair: {\r\n  //   mode: 'x',\r\n  // },\r\n};\r\n\r\ninterface GraphProps {\r\n  data: any[];\r\n  height?: string; // e.g., '200px'\r\n  id?: string;\r\n  loading?: boolean;\r\n  options: any;\r\n  split?: boolean;\r\n  size?: { width: number; height: number };\r\n}\r\n\r\ninterface GraphState {\r\n  showAllTimeSeries: boolean;\r\n}\r\n\r\nexport class Graph extends PureComponent<GraphProps, GraphState> {\r\n  state = {\r\n    showAllTimeSeries: false,\r\n  };\r\n\r\n  getGraphData() {\r\n    const { data } = this.props;\r\n\r\n    return this.state.showAllTimeSeries ? data : data.slice(0, MAX_NUMBER_OF_TIME_SERIES);\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.draw();\r\n  }\r\n\r\n  componentDidUpdate(prevProps: GraphProps) {\r\n    if (\r\n      prevProps.data !== this.props.data ||\r\n      prevProps.options !== this.props.options ||\r\n      prevProps.split !== this.props.split ||\r\n      prevProps.height !== this.props.height ||\r\n      (prevProps.size && prevProps.size.width !== this.props.size.width)\r\n    ) {\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  onShowAllTimeSeries = () => {\r\n    this.setState(\r\n      {\r\n        showAllTimeSeries: true,\r\n      },\r\n      this.draw\r\n    );\r\n  };\r\n\r\n  draw() {\r\n    const { options: userOptions, size } = this.props;\r\n    const data = this.getGraphData();\r\n\r\n    const $el = $(`#${this.props.id}`);\r\n    if (!data) {\r\n      $el.empty();\r\n      return;\r\n    }\r\n    const series = data.map((ts: TimeSeries) => ({\r\n      color: ts.color,\r\n      label: ts.label,\r\n      data: ts.getFlotPairs('null'),\r\n    }));\r\n\r\n    const ticks = (size.width || 0) / 100;\r\n    let { from, to } = userOptions.range;\r\n    if (!moment.isMoment(from)) {\r\n      from = dateMath.parse(from, false);\r\n    }\r\n    if (!moment.isMoment(to)) {\r\n      to = dateMath.parse(to, true);\r\n    }\r\n    const min = from.valueOf();\r\n    const max = to.valueOf();\r\n    const dynamicOptions = {\r\n      xaxis: {\r\n        mode: 'time',\r\n        min: min,\r\n        max: max,\r\n        label: 'Datetime',\r\n        ticks: ticks,\r\n        timeformat: time_format(ticks, min, max),\r\n      },\r\n    };\r\n    const options = {\r\n      ...FLOT_OPTIONS,\r\n      ...dynamicOptions,\r\n      ...userOptions,\r\n    };\r\n    $.plot($el, series, options);\r\n  }\r\n\r\n  render() {\r\n    const { height = '100px', id = 'graph', loading = false } = this.props;\r\n    const data = this.getGraphData();\r\n\r\n    if (!loading && data.length === 0) {\r\n      return (\r\n        <div className=\"panel-container\">\r\n          <div className=\"muted m-a-1\">The queries returned no time series to graph.</div>\r\n        </div>\r\n      );\r\n    }\r\n    return (\r\n      <div>\r\n        {this.props.data.length > MAX_NUMBER_OF_TIME_SERIES &&\r\n          !this.state.showAllTimeSeries && (\r\n            <div className=\"time-series-disclaimer\">\r\n              <i className=\"fa fa-fw fa-warning disclaimer-icon\" />\r\n              {`Showing only ${MAX_NUMBER_OF_TIME_SERIES} time series. `}\r\n              <span className=\"show-all-time-series\" onClick={this.onShowAllTimeSeries}>{`Show all ${\r\n                this.props.data.length\r\n              }`}</span>\r\n            </div>\r\n          )}\r\n        <div className=\"panel-container\">\r\n          <div id={id} className=\"explore-graph\" style={{ height }} />\r\n          <Legend data={data} />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default withSize()(Graph);\r\n","import React, { PureComponent } from 'react';\r\n\r\nconst LegendItem = ({ series }) => (\r\n  <div className=\"graph-legend-series\">\r\n    <div className=\"graph-legend-icon\">\r\n      <i className=\"fa fa-minus pointer\" style={{ color: series.color }} />\r\n    </div>\r\n    <a className=\"graph-legend-alias pointer\" title={series.alias}>\r\n      {series.alias}\r\n    </a>\r\n  </div>\r\n);\r\n\r\nexport default class Legend extends PureComponent<any, any> {\r\n  render() {\r\n    const { className = '', data } = this.props;\r\n    const items = data || [];\r\n    return (\r\n      <div className={`${className} graph-legend ps`}>\r\n        {items.map(series => <LegendItem key={series.id} series={series} />)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Fragment, PureComponent } from 'react';\r\nimport Highlighter from 'react-highlight-words';\r\n\r\nimport { LogsModel } from 'app/core/logs_model';\r\nimport { findHighlightChunksInText } from 'app/core/utils/text';\r\n\r\ninterface LogsProps {\r\n  className?: string;\r\n  data: LogsModel;\r\n  loading: boolean;\r\n}\r\n\r\nconst EXAMPLE_QUERY = '{job=\"default/prometheus\"}';\r\n\r\nexport default class Logs extends PureComponent<LogsProps, {}> {\r\n  render() {\r\n    const { className = '', data } = this.props;\r\n    const hasData = data && data.rows && data.rows.length > 0;\r\n    return (\r\n      <div className={`${className} logs`}>\r\n        {hasData ? (\r\n          <div className=\"logs-entries panel-container\">\r\n            {data.rows.map(row => (\r\n              <Fragment key={row.key}>\r\n                <div className={row.logLevel ? `logs-row-level logs-row-level-${row.logLevel}` : ''} />\r\n                <div title={`${row.timestamp} (${row.timeFromNow})`}>{row.timeLocal}</div>\r\n                <div>\r\n                  <Highlighter\r\n                    textToHighlight={row.entry}\r\n                    searchWords={row.searchWords}\r\n                    findChunks={findHighlightChunksInText}\r\n                    highlightClassName=\"logs-row-match-highlight\"\r\n                  />\r\n                </div>\r\n              </Fragment>\r\n            ))}\r\n          </div>\r\n        ) : null}\r\n        {!hasData ? (\r\n          <div className=\"panel-container\">\r\n            Enter a query like <code>{EXAMPLE_QUERY}</code>\r\n          </div>\r\n        ) : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport moment from 'moment';\r\nimport React from 'react';\r\nimport { Value } from 'slate';\r\nimport Cascader from 'rc-cascader';\r\nimport PluginPrism from 'slate-prism';\r\nimport Prism from 'prismjs';\r\n\r\n// dom also includes Element polyfills\r\nimport { getNextCharacter, getPreviousCousin } from './utils/dom';\r\nimport PrismPromql, { FUNCTIONS } from './slate-plugins/prism/promql';\r\nimport BracesPlugin from './slate-plugins/braces';\r\nimport RunnerPlugin from './slate-plugins/runner';\r\nimport { processLabels, RATE_RANGES, cleanText, parseSelector } from './utils/prometheus';\r\n\r\nimport TypeaheadField, {\r\n  Suggestion,\r\n  SuggestionGroup,\r\n  TypeaheadInput,\r\n  TypeaheadFieldState,\r\n  TypeaheadOutput,\r\n} from './QueryField';\r\n\r\nconst DEFAULT_KEYS = ['job', 'instance'];\r\nconst EMPTY_SELECTOR = '{}';\r\nconst HISTOGRAM_GROUP = '__histograms__';\r\nconst HISTOGRAM_SELECTOR = '{le!=\"\"}'; // Returns all timeseries for histograms\r\nconst HISTORY_ITEM_COUNT = 5;\r\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\r\nconst METRIC_MARK = 'metric';\r\nconst PRISM_SYNTAX = 'promql';\r\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\r\n\r\nexport const wrapLabel = (label: string) => ({ label });\r\nexport const setFunctionMove = (suggestion: Suggestion): Suggestion => {\r\n  suggestion.move = -1;\r\n  return suggestion;\r\n};\r\n\r\n// Syntax highlighting\r\nPrism.languages[PRISM_SYNTAX] = PrismPromql;\r\nfunction setPrismTokens(language, field, values, alias = 'variable') {\r\n  Prism.languages[language][field] = {\r\n    alias,\r\n    pattern: new RegExp(`(?:^|\\\\s)(${values.join('|')})(?:$|\\\\s)`),\r\n  };\r\n}\r\n\r\nexport function addHistoryMetadata(item: Suggestion, history: any[]): Suggestion {\r\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\r\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\r\n  const count = historyForItem.length;\r\n  const recent = historyForItem[0];\r\n  let hint = `Queried ${count} times in the last 24h.`;\r\n  if (recent) {\r\n    const lastQueried = moment(recent.ts).fromNow();\r\n    hint = `${hint} Last queried ${lastQueried}.`;\r\n  }\r\n  return {\r\n    ...item,\r\n    documentation: hint,\r\n  };\r\n}\r\n\r\nexport function groupMetricsByPrefix(metrics: string[], delimiter = '_'): CascaderOption[] {\r\n  // Filter out recording rules and insert as first option\r\n  const ruleRegex = /:\\w+:/;\r\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\r\n  const rulesOption = {\r\n    label: 'Recording rules',\r\n    value: RECORDING_RULES_GROUP,\r\n    children: ruleNames\r\n      .slice()\r\n      .sort()\r\n      .map(name => ({ label: name, value: name })),\r\n  };\r\n\r\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\r\n\r\n  const metricsOptions = _.chain(metrics)\r\n    .filter(metric => !ruleRegex.test(metric))\r\n    .groupBy(metric => metric.split(delimiter)[0])\r\n    .map((metricsForPrefix: string[], prefix: string): CascaderOption => {\r\n      const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\r\n      const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => ({ label: m, value: m }));\r\n      return {\r\n        children,\r\n        label: prefix,\r\n        value: prefix,\r\n      };\r\n    })\r\n    .sortBy('label')\r\n    .value();\r\n\r\n  return [...options, ...metricsOptions];\r\n}\r\n\r\nexport function willApplySuggestion(\r\n  suggestion: string,\r\n  { typeaheadContext, typeaheadText }: TypeaheadFieldState\r\n): string {\r\n  // Modify suggestion based on context\r\n  switch (typeaheadContext) {\r\n    case 'context-labels': {\r\n      const nextChar = getNextCharacter();\r\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\r\n        suggestion += '=';\r\n      }\r\n      break;\r\n    }\r\n\r\n    case 'context-label-values': {\r\n      // Always add quotes and remove existing ones instead\r\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\r\n        suggestion = `\"${suggestion}`;\r\n      }\r\n      if (getNextCharacter() !== '\"') {\r\n        suggestion = `${suggestion}\"`;\r\n      }\r\n      break;\r\n    }\r\n\r\n    default:\r\n  }\r\n  return suggestion;\r\n}\r\n\r\ninterface CascaderOption {\r\n  label: string;\r\n  value: string;\r\n  children?: CascaderOption[];\r\n  disabled?: boolean;\r\n}\r\n\r\ninterface PromQueryFieldProps {\r\n  error?: string;\r\n  hint?: any;\r\n  histogramMetrics?: string[];\r\n  history?: any[];\r\n  initialQuery?: string | null;\r\n  labelKeys?: { [index: string]: string[] }; // metric -> [labelKey,...]\r\n  labelValues?: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\r\n  metrics?: string[];\r\n  metricsByPrefix?: CascaderOption[];\r\n  onClickHintFix?: (action: any) => void;\r\n  onPressEnter?: () => void;\r\n  onQueryChange?: (value: string, override?: boolean) => void;\r\n  portalOrigin?: string;\r\n  request?: (url: string) => any;\r\n  supportsLogs?: boolean; // To be removed after Logging gets its own query field\r\n}\r\n\r\ninterface PromQueryFieldState {\r\n  histogramMetrics: string[];\r\n  labelKeys: { [index: string]: string[] }; // metric -> [labelKey,...]\r\n  labelValues: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\r\n  logLabelOptions: any[];\r\n  metrics: string[];\r\n  metricsOptions: any[];\r\n  metricsByPrefix: CascaderOption[];\r\n  syntaxLoaded: boolean;\r\n}\r\n\r\ninterface PromTypeaheadInput {\r\n  text: string;\r\n  prefix: string;\r\n  wrapperClasses: string[];\r\n  labelKey?: string;\r\n  value?: Value;\r\n}\r\n\r\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\r\n  plugins: any[];\r\n\r\n  constructor(props: PromQueryFieldProps, context) {\r\n    super(props, context);\r\n\r\n    this.plugins = [\r\n      BracesPlugin(),\r\n      RunnerPlugin({ handler: props.onPressEnter }),\r\n      PluginPrism({\r\n        onlyIn: node => node.type === 'code_block',\r\n        getSyntax: node => 'promql',\r\n      }),\r\n    ];\r\n\r\n    this.state = {\r\n      histogramMetrics: props.histogramMetrics || [],\r\n      labelKeys: props.labelKeys || {},\r\n      labelValues: props.labelValues || {},\r\n      logLabelOptions: [],\r\n      metrics: props.metrics || [],\r\n      metricsByPrefix: props.metricsByPrefix || [],\r\n      metricsOptions: [],\r\n      syntaxLoaded: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    // Temporarily reused by logging\r\n    const { supportsLogs } = this.props;\r\n    if (supportsLogs) {\r\n      this.fetchLogLabels();\r\n    } else {\r\n      // Usual actions\r\n      this.fetchMetricNames();\r\n      this.fetchHistogramMetrics();\r\n    }\r\n  }\r\n\r\n  onChangeLogLabels = (values: string[], selectedOptions: CascaderOption[]) => {\r\n    let query;\r\n    if (selectedOptions.length === 1) {\r\n      if (selectedOptions[0].children.length === 0) {\r\n        query = selectedOptions[0].value;\r\n      } else {\r\n        // Ignore click on group\r\n        return;\r\n      }\r\n    } else {\r\n      const key = selectedOptions[0].value;\r\n      const value = selectedOptions[1].value;\r\n      query = `{${key}=\"${value}\"}`;\r\n    }\r\n    this.onChangeQuery(query, true);\r\n  };\r\n\r\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\r\n    let query;\r\n    if (selectedOptions.length === 1) {\r\n      if (selectedOptions[0].children.length === 0) {\r\n        query = selectedOptions[0].value;\r\n      } else {\r\n        // Ignore click on group\r\n        return;\r\n      }\r\n    } else {\r\n      const prefix = selectedOptions[0].value;\r\n      const metric = selectedOptions[1].value;\r\n      if (prefix === HISTOGRAM_GROUP) {\r\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\r\n      } else {\r\n        query = metric;\r\n      }\r\n    }\r\n    this.onChangeQuery(query, true);\r\n  };\r\n\r\n  onChangeQuery = (value: string, override?: boolean) => {\r\n    // Send text change to parent\r\n    const { onQueryChange } = this.props;\r\n    if (onQueryChange) {\r\n      onQueryChange(value, override);\r\n    }\r\n  };\r\n\r\n  onClickHintFix = () => {\r\n    const { hint, onClickHintFix } = this.props;\r\n    if (onClickHintFix && hint && hint.fix) {\r\n      onClickHintFix(hint.fix.action);\r\n    }\r\n  };\r\n\r\n  onReceiveMetrics = () => {\r\n    const { histogramMetrics, metrics, metricsByPrefix } = this.state;\r\n    if (!metrics) {\r\n      return;\r\n    }\r\n\r\n    // Update global prism config\r\n    setPrismTokens(PRISM_SYNTAX, METRIC_MARK, metrics);\r\n\r\n    // Build metrics tree\r\n    const histogramOptions = histogramMetrics.map(hm => ({ label: hm, value: hm }));\r\n    const metricsOptions = [\r\n      { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions },\r\n      ...metricsByPrefix,\r\n    ];\r\n\r\n    this.setState({ metricsOptions, syntaxLoaded: true });\r\n  };\r\n\r\n  onTypeahead = (typeahead: TypeaheadInput): TypeaheadOutput => {\r\n    const { prefix, text, value, wrapperNode } = typeahead;\r\n\r\n    // Get DOM-dependent context\r\n    const wrapperClasses = Array.from(wrapperNode.classList);\r\n    const labelKeyNode = getPreviousCousin(wrapperNode, '.attr-name');\r\n    const labelKey = labelKeyNode && labelKeyNode.textContent;\r\n    const nextChar = getNextCharacter();\r\n\r\n    const result = this.getTypeahead({ text, value, prefix, wrapperClasses, labelKey });\r\n\r\n    console.log('handleTypeahead', wrapperClasses, text, prefix, nextChar, labelKey, result.context);\r\n\r\n    return result;\r\n  };\r\n\r\n  // Keep this DOM-free for testing\r\n  getTypeahead({ prefix, wrapperClasses, text }: PromTypeaheadInput): TypeaheadOutput {\r\n    // Syntax spans have 3 classes by default. More indicate a recognized token\r\n    const tokenRecognized = wrapperClasses.length > 3;\r\n    // Determine candidates by CSS context\r\n    if (_.includes(wrapperClasses, 'context-range')) {\r\n      // Suggestions for metric[|]\r\n      return this.getRangeTypeahead();\r\n    } else if (_.includes(wrapperClasses, 'context-labels')) {\r\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\r\n      return this.getLabelTypeahead.apply(this, arguments);\r\n    } else if (_.includes(wrapperClasses, 'context-aggregation')) {\r\n      return this.getAggregationTypeahead.apply(this, arguments);\r\n    } else if (\r\n      // Show default suggestions in a couple of scenarios\r\n      (prefix && !tokenRecognized) || // Non-empty prefix, but not inside known token\r\n      (prefix === '' && !text.match(/^[\\]})\\s]+$/)) || // Empty prefix, but not following a closing brace\r\n      text.match(/[+\\-*/^%]/) // Anything after binary operator\r\n    ) {\r\n      return this.getEmptyTypeahead();\r\n    }\r\n\r\n    return {\r\n      suggestions: [],\r\n    };\r\n  }\r\n\r\n  getEmptyTypeahead(): TypeaheadOutput {\r\n    const { history } = this.props;\r\n    const { metrics } = this.state;\r\n    const suggestions: SuggestionGroup[] = [];\r\n\r\n    if (history && history.length > 0) {\r\n      const historyItems = _.chain(history)\r\n        .uniqBy('query')\r\n        .take(HISTORY_ITEM_COUNT)\r\n        .map(h => h.query)\r\n        .map(wrapLabel)\r\n        .map(item => addHistoryMetadata(item, history))\r\n        .value();\r\n\r\n      suggestions.push({\r\n        prefixMatch: true,\r\n        skipSort: true,\r\n        label: 'History',\r\n        items: historyItems,\r\n      });\r\n    }\r\n\r\n    suggestions.push({\r\n      prefixMatch: true,\r\n      label: 'Functions',\r\n      items: FUNCTIONS.map(setFunctionMove),\r\n    });\r\n\r\n    if (metrics) {\r\n      suggestions.push({\r\n        label: 'Metrics',\r\n        items: metrics.map(wrapLabel),\r\n      });\r\n    }\r\n    return { suggestions };\r\n  }\r\n\r\n  getRangeTypeahead(): TypeaheadOutput {\r\n    return {\r\n      context: 'context-range',\r\n      suggestions: [\r\n        {\r\n          label: 'Range vector',\r\n          items: [...RATE_RANGES].map(wrapLabel),\r\n        },\r\n      ],\r\n    };\r\n  }\r\n\r\n  getAggregationTypeahead({ value }: PromTypeaheadInput): TypeaheadOutput {\r\n    let refresher: Promise<any> = null;\r\n    const suggestions: SuggestionGroup[] = [];\r\n\r\n    // sum(foo{bar=\"1\"}) by (|)\r\n    const line = value.anchorBlock.getText();\r\n    const cursorOffset: number = value.anchorOffset;\r\n    // sum(foo{bar=\"1\"}) by (\r\n    const leftSide = line.slice(0, cursorOffset);\r\n    const openParensAggregationIndex = leftSide.lastIndexOf('(');\r\n    const openParensSelectorIndex = leftSide.slice(0, openParensAggregationIndex).lastIndexOf('(');\r\n    const closeParensSelectorIndex = leftSide.slice(openParensSelectorIndex).indexOf(')') + openParensSelectorIndex;\r\n    // foo{bar=\"1\"}\r\n    const selectorString = leftSide.slice(openParensSelectorIndex + 1, closeParensSelectorIndex);\r\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\r\n\r\n    const labelKeys = this.state.labelKeys[selector];\r\n    if (labelKeys) {\r\n      suggestions.push({ label: 'Labels', items: labelKeys.map(wrapLabel) });\r\n    } else {\r\n      refresher = this.fetchSeriesLabels(selector);\r\n    }\r\n\r\n    return {\r\n      refresher,\r\n      suggestions,\r\n      context: 'context-aggregation',\r\n    };\r\n  }\r\n\r\n  getLabelTypeahead({ text, wrapperClasses, labelKey, value }: PromTypeaheadInput): TypeaheadOutput {\r\n    let context: string;\r\n    let refresher: Promise<any> = null;\r\n    const suggestions: SuggestionGroup[] = [];\r\n    const line = value.anchorBlock.getText();\r\n    const cursorOffset: number = value.anchorOffset;\r\n\r\n    // Get normalized selector\r\n    let selector;\r\n    let parsedSelector;\r\n    try {\r\n      parsedSelector = parseSelector(line, cursorOffset);\r\n      selector = parsedSelector.selector;\r\n    } catch {\r\n      selector = EMPTY_SELECTOR;\r\n    }\r\n    const containsMetric = selector.indexOf('__name__=') > -1;\r\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\r\n\r\n    if ((text && text.match(/^!?=~?/)) || _.includes(wrapperClasses, 'attr-value')) {\r\n      // Label values\r\n      if (labelKey && this.state.labelValues[selector] && this.state.labelValues[selector][labelKey]) {\r\n        const labelValues = this.state.labelValues[selector][labelKey];\r\n        context = 'context-label-values';\r\n        suggestions.push({\r\n          label: `Label values for \"${labelKey}\"`,\r\n          items: labelValues.map(wrapLabel),\r\n        });\r\n      }\r\n    } else {\r\n      // Label keys\r\n      const labelKeys = this.state.labelKeys[selector] || (containsMetric ? null : DEFAULT_KEYS);\r\n      if (labelKeys) {\r\n        const possibleKeys = _.difference(labelKeys, existingKeys);\r\n        if (possibleKeys.length > 0) {\r\n          context = 'context-labels';\r\n          suggestions.push({ label: `Labels`, items: possibleKeys.map(wrapLabel) });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Query labels for selector\r\n    // Temporarily add skip for logging\r\n    if (selector && !this.state.labelValues[selector] && !this.props.supportsLogs) {\r\n      if (selector === EMPTY_SELECTOR) {\r\n        // Query label values for default labels\r\n        refresher = Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\r\n      } else {\r\n        refresher = this.fetchSeriesLabels(selector, !containsMetric);\r\n      }\r\n    }\r\n\r\n    return { context, refresher, suggestions };\r\n  }\r\n\r\n  request = url => {\r\n    if (this.props.request) {\r\n      return this.props.request(url);\r\n    }\r\n    return fetch(url);\r\n  };\r\n\r\n  fetchHistogramMetrics() {\r\n    this.fetchSeriesLabels(HISTOGRAM_SELECTOR, true, () => {\r\n      const histogramSeries = this.state.labelValues[HISTOGRAM_SELECTOR];\r\n      if (histogramSeries && histogramSeries['__name__']) {\r\n        const histogramMetrics = histogramSeries['__name__'].slice().sort();\r\n        this.setState({ histogramMetrics }, this.onReceiveMetrics);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Temporarily here while reusing this field for logging\r\n  async fetchLogLabels() {\r\n    const url = '/api/prom/label';\r\n    try {\r\n      const res = await this.request(url);\r\n      const body = await (res.data || res.json());\r\n      const labelKeys = body.data.slice().sort();\r\n      const labelKeysBySelector = {\r\n        ...this.state.labelKeys,\r\n        [EMPTY_SELECTOR]: labelKeys,\r\n      };\r\n      const labelValuesByKey = {};\r\n      const logLabelOptions = [];\r\n      for (const key of labelKeys) {\r\n        const valuesUrl = `/api/prom/label/${key}/values`;\r\n        const res = await this.request(valuesUrl);\r\n        const body = await (res.data || res.json());\r\n        const values = body.data.slice().sort();\r\n        labelValuesByKey[key] = values;\r\n        logLabelOptions.push({\r\n          label: key,\r\n          value: key,\r\n          children: values.map(value => ({ label: value, value })),\r\n        });\r\n      }\r\n      const labelValues = { [EMPTY_SELECTOR]: labelValuesByKey };\r\n      this.setState({ labelKeys: labelKeysBySelector, labelValues, logLabelOptions });\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  async fetchLabelValues(key: string) {\r\n    const url = `/api/v1/label/${key}/values`;\r\n    try {\r\n      const res = await this.request(url);\r\n      const body = await (res.data || res.json());\r\n      const exisingValues = this.state.labelValues[EMPTY_SELECTOR];\r\n      const values = {\r\n        ...exisingValues,\r\n        [key]: body.data,\r\n      };\r\n      const labelValues = {\r\n        ...this.state.labelValues,\r\n        [EMPTY_SELECTOR]: values,\r\n      };\r\n      this.setState({ labelValues });\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  async fetchSeriesLabels(name: string, withName?: boolean, callback?: () => void) {\r\n    const url = `/api/v1/series?match[]=${name}`;\r\n    try {\r\n      const res = await this.request(url);\r\n      const body = await (res.data || res.json());\r\n      const { keys, values } = processLabels(body.data, withName);\r\n      const labelKeys = {\r\n        ...this.state.labelKeys,\r\n        [name]: keys,\r\n      };\r\n      const labelValues = {\r\n        ...this.state.labelValues,\r\n        [name]: values,\r\n      };\r\n      this.setState({ labelKeys, labelValues }, callback);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  }\r\n\r\n  async fetchMetricNames() {\r\n    const url = '/api/v1/label/__name__/values';\r\n    try {\r\n      const res = await this.request(url);\r\n      const body = await (res.data || res.json());\r\n      const metrics = body.data;\r\n      const metricsByPrefix = groupMetricsByPrefix(metrics);\r\n      this.setState({ metrics, metricsByPrefix }, this.onReceiveMetrics);\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { error, hint, initialQuery, supportsLogs } = this.props;\r\n    const { logLabelOptions, metricsOptions, syntaxLoaded } = this.state;\r\n\r\n    return (\r\n      <div className=\"prom-query-field\">\r\n        <div className=\"prom-query-field-tools\">\r\n          {supportsLogs ? (\r\n            <Cascader options={logLabelOptions} onChange={this.onChangeLogLabels}>\r\n              <button className=\"btn navbar-button navbar-button--tight\">Log labels</button>\r\n            </Cascader>\r\n          ) : (\r\n            <Cascader options={metricsOptions} onChange={this.onChangeMetrics}>\r\n              <button className=\"btn navbar-button navbar-button--tight\">Metrics</button>\r\n            </Cascader>\r\n          )}\r\n        </div>\r\n        <div className=\"prom-query-field-wrapper\">\r\n          <div className=\"slate-query-field-wrapper\">\r\n            <TypeaheadField\r\n              additionalPlugins={this.plugins}\r\n              cleanText={cleanText}\r\n              initialValue={initialQuery}\r\n              onTypeahead={this.onTypeahead}\r\n              onWillApplySuggestion={willApplySuggestion}\r\n              onValueChanged={this.onChangeQuery}\r\n              placeholder=\"Enter a PromQL query\"\r\n              portalOrigin=\"prometheus\"\r\n              syntaxLoaded={syntaxLoaded}\r\n            />\r\n          </div>\r\n          {error ? <div className=\"prom-query-field-info text-error\">{error}</div> : null}\r\n          {hint ? (\r\n            <div className=\"prom-query-field-info text-warning\">\r\n              {hint.label}{' '}\r\n              {hint.fix ? (\r\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\r\n                  {hint.fix.label}\r\n                </a>\r\n              ) : null}\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PromQueryField;\r\n","import _ from 'lodash';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { Change, Value } from 'slate';\r\nimport { Editor } from 'slate-react';\r\nimport Plain from 'slate-plain-serializer';\r\n\r\nimport ClearPlugin from './slate-plugins/clear';\r\nimport NewlinePlugin from './slate-plugins/newline';\r\n\r\nimport Typeahead from './Typeahead';\r\nimport { makeFragment, makeValue } from './Value';\r\n\r\nexport const TYPEAHEAD_DEBOUNCE = 100;\r\n\r\nfunction getSuggestionByIndex(suggestions: SuggestionGroup[], index: number): Suggestion {\r\n  // Flatten suggestion groups\r\n  const flattenedSuggestions = suggestions.reduce((acc, g) => acc.concat(g.items), []);\r\n  const correctedIndex = Math.max(index, 0) % flattenedSuggestions.length;\r\n  return flattenedSuggestions[correctedIndex];\r\n}\r\n\r\nfunction hasSuggestions(suggestions: SuggestionGroup[]): boolean {\r\n  return suggestions && suggestions.length > 0;\r\n}\r\n\r\nexport interface Suggestion {\r\n  /**\r\n   * The label of this completion item. By default\r\n   * this is also the text that is inserted when selecting\r\n   * this completion.\r\n   */\r\n  label: string;\r\n  /**\r\n   * The kind of this completion item. Based on the kind\r\n   * an icon is chosen by the editor.\r\n   */\r\n  kind?: string;\r\n  /**\r\n   * A human-readable string with additional information\r\n   * about this item, like type or symbol information.\r\n   */\r\n  detail?: string;\r\n  /**\r\n   * A human-readable string, can be Markdown, that represents a doc-comment.\r\n   */\r\n  documentation?: string;\r\n  /**\r\n   * A string that should be used when comparing this item\r\n   * with other items. When `falsy` the `label` is used.\r\n   */\r\n  sortText?: string;\r\n  /**\r\n   * A string that should be used when filtering a set of\r\n   * completion items. When `falsy` the `label` is used.\r\n   */\r\n  filterText?: string;\r\n  /**\r\n   * A string or snippet that should be inserted in a document when selecting\r\n   * this completion. When `falsy` the `label` is used.\r\n   */\r\n  insertText?: string;\r\n  /**\r\n   * Delete number of characters before the caret position,\r\n   * by default the letters from the beginning of the word.\r\n   */\r\n  deleteBackwards?: number;\r\n  /**\r\n   * Number of steps to move after the insertion, can be negative.\r\n   */\r\n  move?: number;\r\n}\r\n\r\nexport interface SuggestionGroup {\r\n  /**\r\n   * Label that will be displayed for all entries of this group.\r\n   */\r\n  label: string;\r\n  /**\r\n   * List of suggestions of this group.\r\n   */\r\n  items: Suggestion[];\r\n  /**\r\n   * If true, match only by prefix (and not mid-word).\r\n   */\r\n  prefixMatch?: boolean;\r\n  /**\r\n   * If true, do not filter items in this group based on the search.\r\n   */\r\n  skipFilter?: boolean;\r\n  /**\r\n   * If true, do not sort items.\r\n   */\r\n  skipSort?: boolean;\r\n}\r\n\r\ninterface TypeaheadFieldProps {\r\n  additionalPlugins?: any[];\r\n  cleanText?: (text: string) => string;\r\n  initialValue: string | null;\r\n  onBlur?: () => void;\r\n  onFocus?: () => void;\r\n  onTypeahead?: (typeahead: TypeaheadInput) => TypeaheadOutput;\r\n  onValueChanged?: (value: Value) => void;\r\n  onWillApplySuggestion?: (suggestion: string, state: TypeaheadFieldState) => string;\r\n  placeholder?: string;\r\n  portalOrigin?: string;\r\n  syntax?: string;\r\n  syntaxLoaded?: boolean;\r\n}\r\n\r\nexport interface TypeaheadFieldState {\r\n  suggestions: SuggestionGroup[];\r\n  typeaheadContext: string | null;\r\n  typeaheadIndex: number;\r\n  typeaheadPrefix: string;\r\n  typeaheadText: string;\r\n  value: Value;\r\n}\r\n\r\nexport interface TypeaheadInput {\r\n  editorNode: Element;\r\n  prefix: string;\r\n  selection?: Selection;\r\n  text: string;\r\n  value: Value;\r\n  wrapperNode: Element;\r\n}\r\n\r\nexport interface TypeaheadOutput {\r\n  context?: string;\r\n  refresher?: Promise<{}>;\r\n  suggestions: SuggestionGroup[];\r\n}\r\n\r\nclass QueryField extends React.PureComponent<TypeaheadFieldProps, TypeaheadFieldState> {\r\n  menuEl: HTMLElement | null;\r\n  plugins: any[];\r\n  resetTimer: any;\r\n\r\n  constructor(props, context) {\r\n    super(props, context);\r\n\r\n    // Base plugins\r\n    this.plugins = [ClearPlugin(), NewlinePlugin(), ...props.additionalPlugins];\r\n\r\n    this.state = {\r\n      suggestions: [],\r\n      typeaheadContext: null,\r\n      typeaheadIndex: 0,\r\n      typeaheadPrefix: '',\r\n      typeaheadText: '',\r\n      value: makeValue(props.initialValue || '', props.syntax),\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.updateMenu();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    clearTimeout(this.resetTimer);\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    // Only update menu location when suggestion existence or text/selection changed\r\n    if (\r\n      this.state.value !== prevState.value ||\r\n      hasSuggestions(this.state.suggestions) !== hasSuggestions(prevState.suggestions)\r\n    ) {\r\n      this.updateMenu();\r\n    }\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps: TypeaheadFieldProps) {\r\n    if (nextProps.syntaxLoaded && !this.props.syntaxLoaded) {\r\n      // Need a bogus edit to re-render the editor after syntax has fully loaded\r\n      this.onChange(\r\n        this.state.value\r\n          .change()\r\n          .insertText(' ')\r\n          .deleteBackward()\r\n      );\r\n    }\r\n  }\r\n\r\n  onChange = ({ value }) => {\r\n    const textChanged = value.document !== this.state.value.document;\r\n\r\n    // Control editor loop, then pass text change up to parent\r\n    this.setState({ value }, () => {\r\n      if (textChanged) {\r\n        this.handleChangeValue();\r\n      }\r\n    });\r\n\r\n    // Show suggest menu on text input\r\n    if (textChanged && value.selection.isCollapsed) {\r\n      // Need one paint to allow DOM-based typeahead rules to work\r\n      window.requestAnimationFrame(this.handleTypeahead);\r\n    } else {\r\n      this.resetTypeahead();\r\n    }\r\n  };\r\n\r\n  handleChangeValue = () => {\r\n    // Send text change to parent\r\n    const { onValueChanged } = this.props;\r\n    if (onValueChanged) {\r\n      onValueChanged(Plain.serialize(this.state.value));\r\n    }\r\n  };\r\n\r\n  handleTypeahead = _.debounce(async () => {\r\n    const selection = window.getSelection();\r\n    const { cleanText, onTypeahead } = this.props;\r\n    const { value } = this.state;\r\n\r\n    if (onTypeahead && selection.anchorNode) {\r\n      const wrapperNode = selection.anchorNode.parentElement;\r\n      const editorNode = wrapperNode.closest('.slate-query-field');\r\n      if (!editorNode || this.state.value.isBlurred) {\r\n        // Not inside this editor\r\n        return;\r\n      }\r\n\r\n      const range = selection.getRangeAt(0);\r\n      const offset = range.startOffset;\r\n      const text = selection.anchorNode.textContent;\r\n      let prefix = text.substr(0, offset);\r\n\r\n      // Label values could have valid characters erased if `cleanText()` is\r\n      // blindly applied, which would undesirably interfere with suggestions\r\n      const labelValueMatch = prefix.match(/(?:!?=~?\"?|\")(.*)/);\r\n      if (labelValueMatch) {\r\n        prefix = labelValueMatch[1];\r\n      } else if (cleanText) {\r\n        prefix = cleanText(prefix);\r\n      }\r\n\r\n      const { suggestions, context, refresher } = onTypeahead({\r\n        editorNode,\r\n        prefix,\r\n        selection,\r\n        text,\r\n        value,\r\n        wrapperNode,\r\n      });\r\n\r\n      let filteredSuggestions = suggestions\r\n        .map(group => {\r\n          if (group.items) {\r\n            if (prefix) {\r\n              // Filter groups based on prefix\r\n              if (!group.skipFilter) {\r\n                group.items = group.items.filter(c => (c.filterText || c.label).length >= prefix.length);\r\n                if (group.prefixMatch) {\r\n                  group.items = group.items.filter(c => (c.filterText || c.label).indexOf(prefix) === 0);\r\n                } else {\r\n                  group.items = group.items.filter(c => (c.filterText || c.label).indexOf(prefix) > -1);\r\n                }\r\n              }\r\n              // Filter out the already typed value (prefix) unless it inserts custom text\r\n              group.items = group.items.filter(c => c.insertText || (c.filterText || c.label) !== prefix);\r\n            }\r\n\r\n            if (!group.skipSort) {\r\n              group.items = _.sortBy(group.items, item => item.sortText || item.label);\r\n            }\r\n          }\r\n          return group;\r\n        })\r\n        .filter(group => group.items && group.items.length > 0); // Filter out empty groups\r\n\r\n      // Keep same object for equality checking later\r\n      if (_.isEqual(filteredSuggestions, this.state.suggestions)) {\r\n        filteredSuggestions = this.state.suggestions;\r\n      }\r\n\r\n      this.setState(\r\n        {\r\n          suggestions: filteredSuggestions,\r\n          typeaheadPrefix: prefix,\r\n          typeaheadContext: context,\r\n          typeaheadText: text,\r\n        },\r\n        () => {\r\n          if (refresher) {\r\n            refresher.then(this.handleTypeahead).catch(e => console.error(e));\r\n          }\r\n        }\r\n      );\r\n    }\r\n  }, TYPEAHEAD_DEBOUNCE);\r\n\r\n  applyTypeahead(change: Change, suggestion: Suggestion): Change {\r\n    const { cleanText, onWillApplySuggestion, syntax } = this.props;\r\n    const { typeaheadPrefix, typeaheadText } = this.state;\r\n    let suggestionText = suggestion.insertText || suggestion.label;\r\n    const move = suggestion.move || 0;\r\n\r\n    if (onWillApplySuggestion) {\r\n      suggestionText = onWillApplySuggestion(suggestionText, { ...this.state });\r\n    }\r\n\r\n    this.resetTypeahead();\r\n\r\n    // Remove the current, incomplete text and replace it with the selected suggestion\r\n    const backward = suggestion.deleteBackwards || typeaheadPrefix.length;\r\n    const text = cleanText ? cleanText(typeaheadText) : typeaheadText;\r\n    const suffixLength = text.length - typeaheadPrefix.length;\r\n    const offset = typeaheadText.indexOf(typeaheadPrefix);\r\n    const midWord = typeaheadPrefix && ((suffixLength > 0 && offset > -1) || suggestionText === typeaheadText);\r\n    const forward = midWord ? suffixLength + offset : 0;\r\n\r\n    // If new-lines, apply suggestion as block\r\n    if (suggestionText.match(/\\n/)) {\r\n      const fragment = makeFragment(suggestionText, syntax);\r\n      return change\r\n        .deleteBackward(backward)\r\n        .deleteForward(forward)\r\n        .insertFragment(fragment)\r\n        .focus();\r\n    }\r\n\r\n    return change\r\n      .deleteBackward(backward)\r\n      .deleteForward(forward)\r\n      .insertText(suggestionText)\r\n      .move(move)\r\n      .focus();\r\n  }\r\n\r\n  onKeyDown = (event, change) => {\r\n    const { typeaheadIndex, suggestions } = this.state;\r\n\r\n    switch (event.key) {\r\n      case 'Escape': {\r\n        if (this.menuEl) {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          this.resetTypeahead();\r\n          return true;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case ' ': {\r\n        if (event.ctrlKey) {\r\n          event.preventDefault();\r\n          this.handleTypeahead();\r\n          return true;\r\n        }\r\n        break;\r\n      }\r\n      case 'Enter':\r\n      case 'Tab': {\r\n        if (this.menuEl) {\r\n          // Dont blur input\r\n          event.preventDefault();\r\n          if (!suggestions || suggestions.length === 0) {\r\n            return undefined;\r\n          }\r\n\r\n          const suggestion = getSuggestionByIndex(suggestions, typeaheadIndex);\r\n          this.applyTypeahead(change, suggestion);\r\n          return true;\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'ArrowDown': {\r\n        if (this.menuEl) {\r\n          // Select next suggestion\r\n          event.preventDefault();\r\n          this.setState({ typeaheadIndex: typeaheadIndex + 1 });\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'ArrowUp': {\r\n        if (this.menuEl) {\r\n          // Select previous suggestion\r\n          event.preventDefault();\r\n          this.setState({ typeaheadIndex: Math.max(0, typeaheadIndex - 1) });\r\n        }\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        // console.log('default key', event.key, event.which, event.charCode, event.locale, data.key);\r\n        break;\r\n      }\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  resetTypeahead = () => {\r\n    this.setState({\r\n      suggestions: [],\r\n      typeaheadIndex: 0,\r\n      typeaheadPrefix: '',\r\n      typeaheadContext: null,\r\n    });\r\n  };\r\n\r\n  handleBlur = () => {\r\n    const { onBlur } = this.props;\r\n    // If we dont wait here, menu clicks wont work because the menu\r\n    // will be gone.\r\n    this.resetTimer = setTimeout(this.resetTypeahead, 100);\r\n    if (onBlur) {\r\n      onBlur();\r\n    }\r\n  };\r\n\r\n  handleFocus = () => {\r\n    const { onFocus } = this.props;\r\n    if (onFocus) {\r\n      onFocus();\r\n    }\r\n  };\r\n\r\n  onClickMenu = (item: Suggestion) => {\r\n    // Manually triggering change\r\n    const change = this.applyTypeahead(this.state.value.change(), item);\r\n    this.onChange(change);\r\n  };\r\n\r\n  updateMenu = () => {\r\n    const { suggestions } = this.state;\r\n    const menu = this.menuEl;\r\n    const selection = window.getSelection();\r\n    const node = selection.anchorNode;\r\n\r\n    // No menu, nothing to do\r\n    if (!menu) {\r\n      return;\r\n    }\r\n\r\n    // No suggestions or blur, remove menu\r\n    if (!hasSuggestions(suggestions)) {\r\n      menu.removeAttribute('style');\r\n      return;\r\n    }\r\n\r\n    // Align menu overlay to editor node\r\n    if (node) {\r\n      // Read from DOM\r\n      const rect = node.parentElement.getBoundingClientRect();\r\n      const scrollX = window.scrollX;\r\n      const scrollY = window.scrollY;\r\n\r\n      // Write DOM\r\n      requestAnimationFrame(() => {\r\n        menu.style.opacity = '1';\r\n        menu.style.top = `${rect.top + scrollY + rect.height + 4}px`;\r\n        menu.style.left = `${rect.left + scrollX - 2}px`;\r\n      });\r\n    }\r\n  };\r\n\r\n  menuRef = el => {\r\n    this.menuEl = el;\r\n  };\r\n\r\n  renderMenu = () => {\r\n    const { portalOrigin } = this.props;\r\n    const { suggestions, typeaheadIndex, typeaheadPrefix } = this.state;\r\n    if (!hasSuggestions(suggestions)) {\r\n      return null;\r\n    }\r\n\r\n    const selectedItem = getSuggestionByIndex(suggestions, typeaheadIndex);\r\n\r\n    // Create typeahead in DOM root so we can later position it absolutely\r\n    return (\r\n      <Portal origin={portalOrigin}>\r\n        <Typeahead\r\n          menuRef={this.menuRef}\r\n          selectedItem={selectedItem}\r\n          onClickItem={this.onClickMenu}\r\n          prefix={typeaheadPrefix}\r\n          groupedItems={suggestions}\r\n        />\r\n      </Portal>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"slate-query-field\">\r\n        {this.renderMenu()}\r\n        <Editor\r\n          autoCorrect={false}\r\n          onBlur={this.handleBlur}\r\n          onKeyDown={this.onKeyDown}\r\n          onChange={this.onChange}\r\n          onFocus={this.handleFocus}\r\n          placeholder={this.props.placeholder}\r\n          plugins={this.plugins}\r\n          spellCheck={false}\r\n          value={this.state.value}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Portal extends React.PureComponent<{ index?: number; origin: string }, {}> {\r\n  node: HTMLElement;\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    const { index = 0, origin = 'query' } = props;\r\n    this.node = document.createElement('div');\r\n    this.node.classList.add(`slate-typeahead`, `slate-typeahead-${origin}-${index}`);\r\n    document.body.appendChild(this.node);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.body.removeChild(this.node);\r\n  }\r\n\r\n  render() {\r\n    return ReactDOM.createPortal(this.props.children, this.node);\r\n  }\r\n}\r\n\r\nexport default QueryField;\r\n","import React, { PureComponent } from 'react';\r\n\r\n// TODO make this datasource-plugin-dependent\r\nimport QueryField from './PromQueryField';\r\n\r\nclass QueryRow extends PureComponent<any, {}> {\r\n  onChangeQuery = (value, override?: boolean) => {\r\n    const { index, onChangeQuery } = this.props;\r\n    if (onChangeQuery) {\r\n      onChangeQuery(value, index, override);\r\n    }\r\n  };\r\n\r\n  onClickAddButton = () => {\r\n    const { index, onAddQueryRow } = this.props;\r\n    if (onAddQueryRow) {\r\n      onAddQueryRow(index);\r\n    }\r\n  };\r\n\r\n  onClickClearButton = () => {\r\n    this.onChangeQuery('', true);\r\n  };\r\n\r\n  onClickHintFix = action => {\r\n    const { index, onClickHintFix } = this.props;\r\n    if (onClickHintFix) {\r\n      onClickHintFix(action, index);\r\n    }\r\n  };\r\n\r\n  onClickRemoveButton = () => {\r\n    const { index, onRemoveQueryRow } = this.props;\r\n    if (onRemoveQueryRow) {\r\n      onRemoveQueryRow(index);\r\n    }\r\n  };\r\n\r\n  onPressEnter = () => {\r\n    const { onExecuteQuery } = this.props;\r\n    if (onExecuteQuery) {\r\n      onExecuteQuery();\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { history, query, queryError, queryHint, request, supportsLogs } = this.props;\r\n    return (\r\n      <div className=\"query-row\">\r\n        <div className=\"query-row-field\">\r\n          <QueryField\r\n            error={queryError}\r\n            hint={queryHint}\r\n            initialQuery={query}\r\n            history={history}\r\n            onClickHintFix={this.onClickHintFix}\r\n            onPressEnter={this.onPressEnter}\r\n            onQueryChange={this.onChangeQuery}\r\n            request={request}\r\n            supportsLogs={supportsLogs}\r\n          />\r\n        </div>\r\n        <div className=\"query-row-tools\">\r\n          <button className=\"btn navbar-button navbar-button--tight\" onClick={this.onClickClearButton}>\r\n            <i className=\"fa fa-times\" />\r\n          </button>\r\n          <button className=\"btn navbar-button navbar-button--tight\" onClick={this.onClickAddButton}>\r\n            <i className=\"fa fa-plus\" />\r\n          </button>\r\n          <button className=\"btn navbar-button navbar-button--tight\" onClick={this.onClickRemoveButton}>\r\n            <i className=\"fa fa-minus\" />\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default class QueryRows extends PureComponent<any, {}> {\r\n  render() {\r\n    const { className = '', queries, queryErrors, queryHints, ...handlers } = this.props;\r\n    return (\r\n      <div className={className}>\r\n        {queries.map((q, index) => (\r\n          <QueryRow\r\n            key={q.key}\r\n            index={index}\r\n            query={q.query}\r\n            queryError={queryErrors[index]}\r\n            queryHint={queryHints[index]}\r\n            {...handlers}\r\n          />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import _ from 'lodash';\r\nimport React, { PureComponent } from 'react';\r\nimport ReactTable from 'react-table';\r\n\r\nimport TableModel from 'app/core/table_model';\r\n\r\nconst EMPTY_TABLE = new TableModel();\r\n\r\ninterface TableProps {\r\n  data: TableModel;\r\n  loading: boolean;\r\n  onClickCell?: (columnKey: string, rowValue: string) => void;\r\n}\r\n\r\nfunction prepareRows(rows, columnNames) {\r\n  return rows.map(cells => _.zipObject(columnNames, cells));\r\n}\r\n\r\nexport default class Table extends PureComponent<TableProps> {\r\n  getCellProps = (state, rowInfo, column) => {\r\n    return {\r\n      onClick: () => {\r\n        const columnKey = column.Header;\r\n        const rowValue = rowInfo.row[columnKey];\r\n        this.props.onClickCell(columnKey, rowValue);\r\n      },\r\n    };\r\n  };\r\n\r\n  render() {\r\n    const { data, loading } = this.props;\r\n    const tableModel = data || EMPTY_TABLE;\r\n    const columnNames = tableModel.columns.map(({ text }) => text);\r\n    const columns = tableModel.columns.map(({ filterable, text }) => ({\r\n      Header: text,\r\n      accessor: text,\r\n      show: text !== 'Time',\r\n      Cell: row => <span className={filterable ? 'link' : ''}>{row.value}</span>,\r\n    }));\r\n    const noDataText = data ? 'The queries returned no data for a table.' : '';\r\n\r\n    return (\r\n      <ReactTable\r\n        columns={columns}\r\n        data={tableModel.rows}\r\n        getTdProps={this.getCellProps}\r\n        loading={loading}\r\n        minRows={0}\r\n        noDataText={noDataText}\r\n        resolveData={data => prepareRows(data, columnNames)}\r\n        showPagination={data}\r\n      />\r\n    );\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react';\r\nimport moment from 'moment';\r\n\r\nimport * as dateMath from 'app/core/utils/datemath';\r\nimport * as rangeUtil from 'app/core/utils/rangeutil';\r\n\r\nconst DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss';\r\nexport const DEFAULT_RANGE = {\r\n  from: 'now-6h',\r\n  to: 'now',\r\n};\r\n\r\nexport function parseTime(value, isUtc = false, asString = false) {\r\n  if (value.indexOf('now') !== -1) {\r\n    return value;\r\n  }\r\n  if (!isNaN(value)) {\r\n    const epoch = parseInt(value, 10);\r\n    const m = isUtc ? moment.utc(epoch) : moment(epoch);\r\n    return asString ? m.format(DATE_FORMAT) : m;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport default class TimePicker extends PureComponent<any, any> {\r\n  dropdownEl: any;\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    const fromRaw = props.range ? props.range.from : DEFAULT_RANGE.from;\r\n    const toRaw = props.range ? props.range.to : DEFAULT_RANGE.to;\r\n    const range = {\r\n      from: parseTime(fromRaw),\r\n      to: parseTime(toRaw),\r\n    };\r\n    this.state = {\r\n      fromRaw: parseTime(fromRaw, props.isUtc, true),\r\n      isOpen: props.isOpen,\r\n      isUtc: props.isUtc,\r\n      rangeString: rangeUtil.describeTimeRange(range),\r\n      refreshInterval: '',\r\n      toRaw: parseTime(toRaw, props.isUtc, true),\r\n    };\r\n  }\r\n\r\n  move(direction) {\r\n    const { onChangeTime } = this.props;\r\n    const { fromRaw, toRaw } = this.state;\r\n    const range = {\r\n      from: dateMath.parse(fromRaw, false),\r\n      to: dateMath.parse(toRaw, true),\r\n    };\r\n\r\n    const timespan = (range.to.valueOf() - range.from.valueOf()) / 2;\r\n    let to, from;\r\n    if (direction === -1) {\r\n      to = range.to.valueOf() - timespan;\r\n      from = range.from.valueOf() - timespan;\r\n    } else if (direction === 1) {\r\n      to = range.to.valueOf() + timespan;\r\n      from = range.from.valueOf() + timespan;\r\n      if (to > Date.now() && range.to < Date.now()) {\r\n        to = Date.now();\r\n        from = range.from.valueOf();\r\n      }\r\n    } else {\r\n      to = range.to.valueOf();\r\n      from = range.from.valueOf();\r\n    }\r\n\r\n    const rangeString = rangeUtil.describeTimeRange(range);\r\n    // No need to convert to UTC again\r\n    to = moment(to);\r\n    from = moment(from);\r\n\r\n    this.setState(\r\n      {\r\n        rangeString,\r\n        fromRaw: from.format(DATE_FORMAT),\r\n        toRaw: to.format(DATE_FORMAT),\r\n      },\r\n      () => {\r\n        onChangeTime({ to, from });\r\n      }\r\n    );\r\n  }\r\n\r\n  handleChangeFrom = e => {\r\n    this.setState({\r\n      fromRaw: e.target.value,\r\n    });\r\n  };\r\n\r\n  handleChangeTo = e => {\r\n    this.setState({\r\n      toRaw: e.target.value,\r\n    });\r\n  };\r\n\r\n  handleClickApply = () => {\r\n    const { onChangeTime } = this.props;\r\n    const { toRaw, fromRaw } = this.state;\r\n    const range = {\r\n      from: dateMath.parse(fromRaw, false),\r\n      to: dateMath.parse(toRaw, true),\r\n    };\r\n    const rangeString = rangeUtil.describeTimeRange(range);\r\n    this.setState(\r\n      {\r\n        isOpen: false,\r\n        rangeString,\r\n      },\r\n      () => {\r\n        if (onChangeTime) {\r\n          onChangeTime(range);\r\n        }\r\n      }\r\n    );\r\n  };\r\n\r\n  handleClickLeft = () => this.move(-1);\r\n  handleClickPicker = () => {\r\n    this.setState(state => ({\r\n      isOpen: !state.isOpen,\r\n    }));\r\n  };\r\n  handleClickRight = () => this.move(1);\r\n  handleClickRefresh = () => {};\r\n  handleClickRelativeOption = range => {\r\n    const { onChangeTime } = this.props;\r\n    const rangeString = rangeUtil.describeTimeRange(range);\r\n    this.setState(\r\n      {\r\n        toRaw: range.to,\r\n        fromRaw: range.from,\r\n        isOpen: false,\r\n        rangeString,\r\n      },\r\n      () => {\r\n        if (onChangeTime) {\r\n          onChangeTime(range);\r\n        }\r\n      }\r\n    );\r\n  };\r\n\r\n  getTimeOptions() {\r\n    return rangeUtil.getRelativeTimesList({}, this.state.rangeString);\r\n  }\r\n\r\n  dropdownRef = el => {\r\n    this.dropdownEl = el;\r\n  };\r\n\r\n  renderDropdown() {\r\n    const { fromRaw, isOpen, toRaw } = this.state;\r\n    if (!isOpen) {\r\n      return null;\r\n    }\r\n    const timeOptions = this.getTimeOptions();\r\n    return (\r\n      <div ref={this.dropdownRef} className=\"gf-timepicker-dropdown\">\r\n        <div className=\"gf-timepicker-absolute-section\">\r\n          <h3 className=\"section-heading\">Custom range</h3>\r\n\r\n          <label className=\"small\">From:</label>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form max-width-28\">\r\n              <input\r\n                type=\"text\"\r\n                className=\"gf-form-input input-large timepicker-from\"\r\n                value={fromRaw}\r\n                onChange={this.handleChangeFrom}\r\n              />\r\n            </div>\r\n          </div>\r\n\r\n          <label className=\"small\">To:</label>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form max-width-28\">\r\n              <input\r\n                type=\"text\"\r\n                className=\"gf-form-input input-large timepicker-to\"\r\n                value={toRaw}\r\n                onChange={this.handleChangeTo}\r\n              />\r\n            </div>\r\n          </div>\r\n\r\n          {/* <label className=\"small\">Refreshing every:</label>\r\n          <div className=\"gf-form-inline\">\r\n            <div className=\"gf-form max-width-28\">\r\n              <select className=\"gf-form-input input-medium\" ng-options=\"f.value as f.text for f in ctrl.refresh.options\"></select>\r\n            </div>\r\n          </div> */}\r\n          <div className=\"gf-form\">\r\n            <button className=\"btn gf-form-btn btn-secondary\" onClick={this.handleClickApply}>\r\n              Apply\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"gf-timepicker-relative-section\">\r\n          <h3 className=\"section-heading\">Quick ranges</h3>\r\n          {Object.keys(timeOptions).map(section => {\r\n            const group = timeOptions[section];\r\n            return (\r\n              <ul key={section}>\r\n                {group.map(option => (\r\n                  <li className={option.active ? 'active' : ''} key={option.display}>\r\n                    <a onClick={() => this.handleClickRelativeOption(option)}>{option.display}</a>\r\n                  </li>\r\n                ))}\r\n              </ul>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { isUtc, rangeString, refreshInterval } = this.state;\r\n    return (\r\n      <div className=\"timepicker\">\r\n        <div className=\"navbar-buttons\">\r\n          <button className=\"btn navbar-button navbar-button--tight timepicker-left\" onClick={this.handleClickLeft}>\r\n            <i className=\"fa fa-chevron-left\" />\r\n          </button>\r\n          <button className=\"btn navbar-button gf-timepicker-nav-btn\" onClick={this.handleClickPicker}>\r\n            <i className=\"fa fa-clock-o\" />\r\n            <span className=\"timepicker-rangestring\">{rangeString}</span>\r\n            {isUtc ? <span className=\"gf-timepicker-utc\">UTC</span> : null}\r\n            {refreshInterval ? <span className=\"text-warning\">&nbsp; Refresh every {refreshInterval}</span> : null}\r\n          </button>\r\n          <button className=\"btn navbar-button navbar-button--tight timepicker-right\" onClick={this.handleClickRight}>\r\n            <i className=\"fa fa-chevron-right\" />\r\n          </button>\r\n        </div>\r\n        {this.renderDropdown()}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from 'react';\r\nimport Highlighter from 'react-highlight-words';\r\n\r\nimport { Suggestion, SuggestionGroup } from './QueryField';\r\n\r\nfunction scrollIntoView(el: HTMLElement) {\r\n  if (!el || !el.offsetParent) {\r\n    return;\r\n  }\r\n  const container = el.offsetParent as HTMLElement;\r\n  if (el.offsetTop > container.scrollTop + container.offsetHeight || el.offsetTop < container.scrollTop) {\r\n    container.scrollTop = el.offsetTop - container.offsetTop;\r\n  }\r\n}\r\n\r\ninterface TypeaheadItemProps {\r\n  isSelected: boolean;\r\n  item: Suggestion;\r\n  onClickItem: (Suggestion) => void;\r\n  prefix?: string;\r\n}\r\n\r\nclass TypeaheadItem extends React.PureComponent<TypeaheadItemProps, {}> {\r\n  el: HTMLElement;\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (this.props.isSelected && !prevProps.isSelected) {\r\n      requestAnimationFrame(() => {\r\n        scrollIntoView(this.el);\r\n      });\r\n    }\r\n  }\r\n\r\n  getRef = el => {\r\n    this.el = el;\r\n  };\r\n\r\n  onClick = () => {\r\n    this.props.onClickItem(this.props.item);\r\n  };\r\n\r\n  render() {\r\n    const { isSelected, item, prefix } = this.props;\r\n    const className = isSelected ? 'typeahead-item typeahead-item__selected' : 'typeahead-item';\r\n    const { label } = item;\r\n    return (\r\n      <li ref={this.getRef} className={className} onClick={this.onClick}>\r\n        <Highlighter textToHighlight={label} searchWords={[prefix]} highlightClassName=\"typeahead-match\" />\r\n        {item.documentation && isSelected ? <div className=\"typeahead-item-hint\">{item.documentation}</div> : null}\r\n      </li>\r\n    );\r\n  }\r\n}\r\n\r\ninterface TypeaheadGroupProps {\r\n  items: Suggestion[];\r\n  label: string;\r\n  onClickItem: (Suggestion) => void;\r\n  selected: Suggestion;\r\n  prefix?: string;\r\n}\r\n\r\nclass TypeaheadGroup extends React.PureComponent<TypeaheadGroupProps, {}> {\r\n  render() {\r\n    const { items, label, selected, onClickItem, prefix } = this.props;\r\n    return (\r\n      <li className=\"typeahead-group\">\r\n        <div className=\"typeahead-group__title\">{label}</div>\r\n        <ul className=\"typeahead-group__list\">\r\n          {items.map(item => {\r\n            return (\r\n              <TypeaheadItem\r\n                key={item.label}\r\n                onClickItem={onClickItem}\r\n                isSelected={selected === item}\r\n                item={item}\r\n                prefix={prefix}\r\n              />\r\n            );\r\n          })}\r\n        </ul>\r\n      </li>\r\n    );\r\n  }\r\n}\r\n\r\ninterface TypeaheadProps {\r\n  groupedItems: SuggestionGroup[];\r\n  menuRef: any;\r\n  selectedItem: Suggestion | null;\r\n  onClickItem: (Suggestion) => void;\r\n  prefix?: string;\r\n}\r\nclass Typeahead extends React.PureComponent<TypeaheadProps, {}> {\r\n  render() {\r\n    const { groupedItems, menuRef, selectedItem, onClickItem, prefix } = this.props;\r\n    return (\r\n      <ul className=\"typeahead\" ref={menuRef}>\r\n        {groupedItems.map(g => (\r\n          <TypeaheadGroup key={g.label} onClickItem={onClickItem} prefix={prefix} selected={selectedItem} {...g} />\r\n        ))}\r\n      </ul>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Typeahead;\r\n","import { Block, Document, Text, Value } from 'slate';\r\n\r\nconst SCHEMA = {\r\n  blocks: {\r\n    paragraph: 'paragraph',\r\n    codeblock: 'code_block',\r\n    codeline: 'code_line',\r\n  },\r\n  inlines: {},\r\n  marks: {},\r\n};\r\n\r\nexport const makeFragment = (text: string, syntax?: string) => {\r\n  const lines = text.split('\\n').map(line =>\r\n    Block.create({\r\n      type: 'code_line',\r\n      nodes: [Text.create(line)],\r\n    })\r\n  );\r\n\r\n  const block = Block.create({\r\n    data: {\r\n      syntax,\r\n    },\r\n    type: 'code_block',\r\n    nodes: lines,\r\n  });\r\n\r\n  return Document.create({\r\n    nodes: [block],\r\n  });\r\n};\r\n\r\nexport const makeValue = (text: string, syntax?: string) => {\r\n  const fragment = makeFragment(text, syntax);\r\n\r\n  return Value.create({\r\n    document: fragment,\r\n    SCHEMA,\r\n  });\r\n};\r\n","import React, { Component } from 'react';\r\nimport { hot } from 'react-hot-loader';\r\nimport { connect } from 'react-redux';\r\n\r\nimport { updateLocation } from 'app/core/actions';\r\nimport { serializeStateToUrlParam, parseUrlState } from 'app/core/utils/explore';\r\nimport { StoreState } from 'app/types';\r\nimport { ExploreState } from 'app/types/explore';\r\n\r\nimport Explore from './Explore';\r\n\r\ninterface WrapperProps {\r\n  backendSrv?: any;\r\n  datasourceSrv?: any;\r\n  updateLocation: typeof updateLocation;\r\n  urlStates: { [key: string]: string };\r\n}\r\n\r\ninterface WrapperState {\r\n  split: boolean;\r\n  splitState: ExploreState;\r\n}\r\n\r\nconst STATE_KEY_LEFT = 'state';\r\nconst STATE_KEY_RIGHT = 'stateRight';\r\n\r\nexport class Wrapper extends Component<WrapperProps, WrapperState> {\r\n  urlStates: { [key: string]: string };\r\n\r\n  constructor(props: WrapperProps) {\r\n    super(props);\r\n    this.urlStates = props.urlStates;\r\n    this.state = {\r\n      split: Boolean(props.urlStates[STATE_KEY_RIGHT]),\r\n      splitState: undefined,\r\n    };\r\n  }\r\n\r\n  onChangeSplit = (split: boolean, splitState: ExploreState) => {\r\n    this.setState({ split, splitState });\r\n    // When closing split, remove URL state for split part\r\n    if (!split) {\r\n      delete this.urlStates[STATE_KEY_RIGHT];\r\n      this.props.updateLocation({\r\n        query: this.urlStates,\r\n      });\r\n    }\r\n  };\r\n\r\n  onSaveState = (key: string, state: ExploreState) => {\r\n    const urlState = serializeStateToUrlParam(state, true);\r\n    this.urlStates[key] = urlState;\r\n    this.props.updateLocation({\r\n      query: this.urlStates,\r\n    });\r\n  };\r\n\r\n  render() {\r\n    const { datasourceSrv } = this.props;\r\n    // State overrides for props from first Explore\r\n    const { split, splitState } = this.state;\r\n    const urlStateLeft = parseUrlState(this.urlStates[STATE_KEY_LEFT]);\r\n    const urlStateRight = parseUrlState(this.urlStates[STATE_KEY_RIGHT]);\r\n    return (\r\n      <div className=\"explore-wrapper\">\r\n        <Explore\r\n          datasourceSrv={datasourceSrv}\r\n          onChangeSplit={this.onChangeSplit}\r\n          onSaveState={this.onSaveState}\r\n          position=\"left\"\r\n          split={split}\r\n          stateKey={STATE_KEY_LEFT}\r\n          urlState={urlStateLeft}\r\n        />\r\n        {split && (\r\n          <Explore\r\n            datasourceSrv={datasourceSrv}\r\n            onChangeSplit={this.onChangeSplit}\r\n            onSaveState={this.onSaveState}\r\n            position=\"right\"\r\n            split={split}\r\n            splitState={splitState}\r\n            stateKey={STATE_KEY_RIGHT}\r\n            urlState={urlStateRight}\r\n          />\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = (state: StoreState) => ({\r\n  urlStates: state.location.query,\r\n});\r\n\r\nconst mapDispatchToProps = {\r\n  updateLocation,\r\n};\r\n\r\nexport default hot(module)(connect(mapStateToProps, mapDispatchToProps)(Wrapper));\r\n","const BRACES = {\r\n  '[': ']',\r\n  '{': '}',\r\n  '(': ')',\r\n};\r\n\r\nconst NON_SELECTOR_SPACE_REGEXP = / (?![^}]+})/;\r\n\r\nexport default function BracesPlugin() {\r\n  return {\r\n    onKeyDown(event, change) {\r\n      const { value } = change;\r\n      if (!value.isCollapsed) {\r\n        return undefined;\r\n      }\r\n\r\n      switch (event.key) {\r\n        case '{':\r\n        case '[': {\r\n          event.preventDefault();\r\n          // Insert matching braces\r\n          change\r\n            .insertText(`${event.key}${BRACES[event.key]}`)\r\n            .move(-1)\r\n            .focus();\r\n          return true;\r\n        }\r\n\r\n        case '(': {\r\n          event.preventDefault();\r\n          const text = value.anchorText.text;\r\n          const offset = value.anchorOffset;\r\n          const delimiterIndex = text.slice(offset).search(NON_SELECTOR_SPACE_REGEXP);\r\n          const length = delimiterIndex > -1 ? delimiterIndex + offset : text.length;\r\n          const forward = length - offset;\r\n          // Insert matching braces\r\n          change\r\n            .insertText(event.key)\r\n            .move(forward)\r\n            .insertText(BRACES[event.key])\r\n            .move(-1 - forward)\r\n            .focus();\r\n          return true;\r\n        }\r\n\r\n        case 'Backspace': {\r\n          const text = value.anchorText.text;\r\n          const offset = value.anchorOffset;\r\n          const previousChar = text[offset - 1];\r\n          const nextChar = text[offset];\r\n          if (BRACES[previousChar] && BRACES[previousChar] === nextChar) {\r\n            event.preventDefault();\r\n            // Remove closing brace if directly following\r\n            change\r\n              .deleteBackward()\r\n              .deleteForward()\r\n              .focus();\r\n            return true;\r\n          }\r\n        }\r\n\r\n        default: {\r\n          break;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n  };\r\n}\r\n","// Clears the rest of the line after the caret\r\nexport default function ClearPlugin() {\r\n  return {\r\n    onKeyDown(event, change) {\r\n      const { value } = change;\r\n      if (!value.isCollapsed) {\r\n        return undefined;\r\n      }\r\n\r\n      if (event.key === 'k' && event.ctrlKey) {\r\n        event.preventDefault();\r\n        const text = value.anchorText.text;\r\n        const offset = value.anchorOffset;\r\n        const length = text.length;\r\n        const forward = length - offset;\r\n        change.deleteForward(forward);\r\n        return true;\r\n      }\r\n      return undefined;\r\n    },\r\n  };\r\n}\r\n","function getIndent(text) {\r\n  let offset = text.length - text.trimLeft().length;\r\n  if (offset) {\r\n    let indent = text[0];\r\n    while (--offset) {\r\n      indent += text[0];\r\n    }\r\n    return indent;\r\n  }\r\n  return '';\r\n}\r\n\r\nexport default function NewlinePlugin() {\r\n  return {\r\n    onKeyDown(event, change) {\r\n      const { value } = change;\r\n      if (!value.isCollapsed) {\r\n        return undefined;\r\n      }\r\n\r\n      if (event.key === 'Enter' && event.shiftKey) {\r\n        event.preventDefault();\r\n\r\n        const { startBlock } = value;\r\n        const currentLineText = startBlock.text;\r\n        const indent = getIndent(currentLineText);\r\n\r\n        return change\r\n          .splitBlock()\r\n          .insertText(indent)\r\n          .focus();\r\n      }\r\n    },\r\n  };\r\n}\r\n","/* tslint:disable max-line-length */\r\n\r\nexport const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\r\n\r\nconst AGGREGATION_OPERATORS = [\r\n  {\r\n    label: 'sum',\r\n    insertText: 'sum()',\r\n    documentation: 'Calculate sum over dimensions',\r\n  },\r\n  {\r\n    label: 'min',\r\n    insertText: 'min()',\r\n    documentation: 'Select minimum over dimensions',\r\n  },\r\n  {\r\n    label: 'max',\r\n    insertText: 'max()',\r\n    documentation: 'Select maximum over dimensions',\r\n  },\r\n  {\r\n    label: 'avg',\r\n    insertText: 'avg()',\r\n    documentation: 'Calculate the average over dimensions',\r\n  },\r\n  {\r\n    label: 'stddev',\r\n    insertText: 'stddev()',\r\n    documentation: 'Calculate population standard deviation over dimensions',\r\n  },\r\n  {\r\n    label: 'stdvar',\r\n    insertText: 'stdvar()',\r\n    documentation: 'Calculate population standard variance over dimensions',\r\n  },\r\n  {\r\n    label: 'count',\r\n    insertText: 'count()',\r\n    documentation: 'Count number of elements in the vector',\r\n  },\r\n  {\r\n    label: 'count_values',\r\n    insertText: 'count_values()',\r\n    documentation: 'Count number of elements with the same value',\r\n  },\r\n  {\r\n    label: 'bottomk',\r\n    insertText: 'bottomk()',\r\n    documentation: 'Smallest k elements by sample value',\r\n  },\r\n  {\r\n    label: 'topk',\r\n    insertText: 'topk()',\r\n    documentation: 'Largest k elements by sample value',\r\n  },\r\n  {\r\n    label: 'quantile',\r\n    insertText: 'quantile()',\r\n    documentation: 'Calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions',\r\n  },\r\n];\r\n\r\nexport const FUNCTIONS = [\r\n  ...AGGREGATION_OPERATORS,\r\n  {\r\n    insertText: 'abs()',\r\n    label: 'abs',\r\n    detail: 'abs(v instant-vector)',\r\n    documentation: 'Returns the input vector with all sample values converted to their absolute value.',\r\n  },\r\n  {\r\n    insertText: 'absent()',\r\n    label: 'absent',\r\n    detail: 'absent(v instant-vector)',\r\n    documentation:\r\n      'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.',\r\n  },\r\n  {\r\n    insertText: 'ceil()',\r\n    label: 'ceil',\r\n    detail: 'ceil(v instant-vector)',\r\n    documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.',\r\n  },\r\n  {\r\n    insertText: 'changes()',\r\n    label: 'changes',\r\n    detail: 'changes(v range-vector)',\r\n    documentation:\r\n      'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.',\r\n  },\r\n  {\r\n    insertText: 'clamp_max()',\r\n    label: 'clamp_max',\r\n    detail: 'clamp_max(v instant-vector, max scalar)',\r\n    documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.',\r\n  },\r\n  {\r\n    insertText: 'clamp_min()',\r\n    label: 'clamp_min',\r\n    detail: 'clamp_min(v instant-vector, min scalar)',\r\n    documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.',\r\n  },\r\n  {\r\n    insertText: 'count_scalar()',\r\n    label: 'count_scalar',\r\n    detail: 'count_scalar(v instant-vector)',\r\n    documentation:\r\n      'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.',\r\n  },\r\n  {\r\n    insertText: 'day_of_month()',\r\n    label: 'day_of_month',\r\n    detail: 'day_of_month(v=vector(time()) instant-vector)',\r\n    documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.',\r\n  },\r\n  {\r\n    insertText: 'day_of_week()',\r\n    label: 'day_of_week',\r\n    detail: 'day_of_week(v=vector(time()) instant-vector)',\r\n    documentation:\r\n      'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.',\r\n  },\r\n  {\r\n    insertText: 'days_in_month()',\r\n    label: 'days_in_month',\r\n    detail: 'days_in_month(v=vector(time()) instant-vector)',\r\n    documentation:\r\n      'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.',\r\n  },\r\n  {\r\n    insertText: 'delta()',\r\n    label: 'delta',\r\n    detail: 'delta(v range-vector)',\r\n    documentation:\r\n      'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.',\r\n  },\r\n  {\r\n    insertText: 'deriv()',\r\n    label: 'deriv',\r\n    detail: 'deriv(v range-vector)',\r\n    documentation:\r\n      'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.',\r\n  },\r\n  {\r\n    insertText: 'drop_common_labels()',\r\n    label: 'drop_common_labels',\r\n    detail: 'drop_common_labels(instant-vector)',\r\n    documentation: 'Drops all labels that have the same name and value across all series in the input vector.',\r\n  },\r\n  {\r\n    insertText: 'exp()',\r\n    label: 'exp',\r\n    detail: 'exp(v instant-vector)',\r\n    documentation:\r\n      'Calculates the exponential function for all elements in `v`.\\nSpecial cases are:\\n* `Exp(+Inf) = +Inf` \\n* `Exp(NaN) = NaN`',\r\n  },\r\n  {\r\n    insertText: 'floor()',\r\n    label: 'floor',\r\n    detail: 'floor(v instant-vector)',\r\n    documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.',\r\n  },\r\n  {\r\n    insertText: 'histogram_quantile()',\r\n    label: 'histogram_quantile',\r\n    detail: 'histogram_quantile(φ float, b instant-vector)',\r\n    documentation:\r\n      'Calculates the φ-quantile (0 ≤ φ ≤ 1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.',\r\n  },\r\n  {\r\n    insertText: 'holt_winters()',\r\n    label: 'holt_winters',\r\n    detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',\r\n    documentation:\r\n      'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.',\r\n  },\r\n  {\r\n    insertText: 'hour()',\r\n    label: 'hour',\r\n    detail: 'hour(v=vector(time()) instant-vector)',\r\n    documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.',\r\n  },\r\n  {\r\n    insertText: 'idelta()',\r\n    label: 'idelta',\r\n    detail: 'idelta(v range-vector)',\r\n    documentation:\r\n      'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.',\r\n  },\r\n  {\r\n    insertText: 'increase()',\r\n    label: 'increase',\r\n    detail: 'increase(v range-vector)',\r\n    documentation:\r\n      'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.',\r\n  },\r\n  {\r\n    insertText: 'irate()',\r\n    label: 'irate',\r\n    detail: 'irate(v range-vector)',\r\n    documentation:\r\n      'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.',\r\n  },\r\n  {\r\n    insertText: 'label_replace()',\r\n    label: 'label_replace',\r\n    detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',\r\n    documentation:\r\n      \"For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged.\",\r\n  },\r\n  {\r\n    insertText: 'ln()',\r\n    label: 'ln',\r\n    detail: 'ln(v instant-vector)',\r\n    documentation:\r\n      'calculates the natural logarithm for all elements in `v`.\\nSpecial cases are:\\n * `ln(+Inf) = +Inf`\\n * `ln(0) = -Inf`\\n * `ln(x < 0) = NaN`\\n * `ln(NaN) = NaN`',\r\n  },\r\n  {\r\n    insertText: 'log2()',\r\n    label: 'log2',\r\n    detail: 'log2(v instant-vector)',\r\n    documentation:\r\n      'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\r\n  },\r\n  {\r\n    insertText: 'log10()',\r\n    label: 'log10',\r\n    detail: 'log10(v instant-vector)',\r\n    documentation:\r\n      'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\r\n  },\r\n  {\r\n    insertText: 'minute()',\r\n    label: 'minute',\r\n    detail: 'minute(v=vector(time()) instant-vector)',\r\n    documentation:\r\n      'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.',\r\n  },\r\n  {\r\n    insertText: 'month()',\r\n    label: 'month',\r\n    detail: 'month(v=vector(time()) instant-vector)',\r\n    documentation:\r\n      'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.',\r\n  },\r\n  {\r\n    insertText: 'predict_linear()',\r\n    label: 'predict_linear',\r\n    detail: 'predict_linear(v range-vector, t scalar)',\r\n    documentation:\r\n      'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.',\r\n  },\r\n  {\r\n    insertText: 'rate()',\r\n    label: 'rate',\r\n    detail: 'rate(v range-vector)',\r\n    documentation:\r\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\r\n  },\r\n  {\r\n    insertText: 'resets()',\r\n    label: 'resets',\r\n    detail: 'resets(v range-vector)',\r\n    documentation:\r\n      'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.',\r\n  },\r\n  {\r\n    insertText: 'round()',\r\n    label: 'round',\r\n    detail: 'round(v instant-vector, to_nearest=1 scalar)',\r\n    documentation:\r\n      'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.',\r\n  },\r\n  {\r\n    insertText: 'scalar()',\r\n    label: 'scalar',\r\n    detail: 'scalar(v instant-vector)',\r\n    documentation:\r\n      'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.',\r\n  },\r\n  {\r\n    insertText: 'sort()',\r\n    label: 'sort',\r\n    detail: 'sort(v instant-vector)',\r\n    documentation: 'Returns vector elements sorted by their sample values, in ascending order.',\r\n  },\r\n  {\r\n    insertText: 'sort_desc()',\r\n    label: 'sort_desc',\r\n    detail: 'sort_desc(v instant-vector)',\r\n    documentation: 'Returns vector elements sorted by their sample values, in descending order.',\r\n  },\r\n  {\r\n    insertText: 'sqrt()',\r\n    label: 'sqrt',\r\n    detail: 'sqrt(v instant-vector)',\r\n    documentation: 'Calculates the square root of all elements in `v`.',\r\n  },\r\n  {\r\n    insertText: 'time()',\r\n    label: 'time',\r\n    detail: 'time()',\r\n    documentation:\r\n      'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.',\r\n  },\r\n  {\r\n    insertText: 'vector()',\r\n    label: 'vector',\r\n    detail: 'vector(s scalar)',\r\n    documentation: 'Returns the scalar `s` as a vector with no labels.',\r\n  },\r\n  {\r\n    insertText: 'year()',\r\n    label: 'year',\r\n    detail: 'year(v=vector(time()) instant-vector)',\r\n    documentation: 'Returns the year for each of the given times in UTC.',\r\n  },\r\n  {\r\n    insertText: 'avg_over_time()',\r\n    label: 'avg_over_time',\r\n    detail: 'avg_over_time(range-vector)',\r\n    documentation: 'The average value of all points in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'min_over_time()',\r\n    label: 'min_over_time',\r\n    detail: 'min_over_time(range-vector)',\r\n    documentation: 'The minimum value of all points in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'max_over_time()',\r\n    label: 'max_over_time',\r\n    detail: 'max_over_time(range-vector)',\r\n    documentation: 'The maximum value of all points in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'sum_over_time()',\r\n    label: 'sum_over_time',\r\n    detail: 'sum_over_time(range-vector)',\r\n    documentation: 'The sum of all values in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'count_over_time()',\r\n    label: 'count_over_time',\r\n    detail: 'count_over_time(range-vector)',\r\n    documentation: 'The count of all values in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'quantile_over_time()',\r\n    label: 'quantile_over_time',\r\n    detail: 'quantile_over_time(scalar, range-vector)',\r\n    documentation: 'The φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'stddev_over_time()',\r\n    label: 'stddev_over_time',\r\n    detail: 'stddev_over_time(range-vector)',\r\n    documentation: 'The population standard deviation of the values in the specified interval.',\r\n  },\r\n  {\r\n    insertText: 'stdvar_over_time()',\r\n    label: 'stdvar_over_time',\r\n    detail: 'stdvar_over_time(range-vector)',\r\n    documentation: 'The population standard variance of the values in the specified interval.',\r\n  },\r\n];\r\n\r\nconst tokenizer = {\r\n  comment: {\r\n    pattern: /(^|[^\\n])#.*/,\r\n    lookbehind: true,\r\n  },\r\n  'context-aggregation': {\r\n    pattern: /((by|without)\\s*)\\([^)]*\\)/, // by ()\r\n    lookbehind: true,\r\n    inside: {\r\n      'label-key': {\r\n        pattern: /[^,\\s][^,]*[^,\\s]*/,\r\n        alias: 'attr-name',\r\n      },\r\n    },\r\n  },\r\n  'context-labels': {\r\n    pattern: /\\{[^}]*(?=})/,\r\n    inside: {\r\n      'label-key': {\r\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\r\n        alias: 'attr-name',\r\n      },\r\n      'label-value': {\r\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\r\n        greedy: true,\r\n        alias: 'attr-value',\r\n      },\r\n    },\r\n  },\r\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\r\n  'context-range': [\r\n    {\r\n      pattern: /\\[[^\\]]*(?=])/, // [1m]\r\n      inside: {\r\n        'range-duration': {\r\n          pattern: /\\b\\d+[smhdwy]\\b/i,\r\n          alias: 'number',\r\n        },\r\n      },\r\n    },\r\n    {\r\n      pattern: /(offset\\s+)\\w+/, // offset 1m\r\n      lookbehind: true,\r\n      inside: {\r\n        'range-duration': {\r\n          pattern: /\\b\\d+[smhdwy]\\b/i,\r\n          alias: 'number',\r\n        },\r\n      },\r\n    },\r\n  ],\r\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\r\n  operator: new RegExp(`/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:${OPERATORS.join('|')})\\\\b`, 'i'),\r\n  punctuation: /[{};()`,.]/,\r\n};\r\n\r\nexport default tokenizer;\r\n","export default function RunnerPlugin({ handler }) {\r\n  return {\r\n    onKeyDown(event) {\r\n      // Handle enter\r\n      if (handler && event.key === 'Enter' && !event.shiftKey) {\r\n        // Submit on Enter\r\n        event.preventDefault();\r\n        handler(event);\r\n        return true;\r\n      }\r\n      return undefined;\r\n    },\r\n  };\r\n}\r\n","// Node.closest() polyfill\r\nif ('Element' in window && !Element.prototype.closest) {\r\n  Element.prototype.closest = function(this: any, s) {\r\n    const matches = (this.document || this.ownerDocument).querySelectorAll(s);\r\n    let el = this;\r\n    let i;\r\n    // eslint-disable-next-line\r\n    do {\r\n      i = matches.length;\r\n      // eslint-disable-next-line\r\n      while (--i >= 0 && matches.item(i) !== el) {}\r\n      el = el.parentElement;\r\n    } while (i < 0 && el);\r\n    return el;\r\n  };\r\n}\r\n\r\nexport function getPreviousCousin(node, selector) {\r\n  let sibling = node.parentElement.previousSibling;\r\n  let el;\r\n  while (sibling) {\r\n    el = sibling.querySelector(selector);\r\n    if (el) {\r\n      return el;\r\n    }\r\n    sibling = sibling.previousSibling;\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport function getNextCharacter(global = window) {\r\n  const selection = global.getSelection();\r\n  if (!selection.anchorNode) {\r\n    return null;\r\n  }\r\n\r\n  const range = selection.getRangeAt(0);\r\n  const text = selection.anchorNode.textContent;\r\n  const offset = range.startOffset;\r\n  return text.substr(offset, 1);\r\n}\r\n","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\r\n\r\nexport function processLabels(labels, withName = false) {\r\n  const values = {};\r\n  labels.forEach(l => {\r\n    const { __name__, ...rest } = l;\r\n    if (withName) {\r\n      values['__name__'] = values['__name__'] || [];\r\n      if (values['__name__'].indexOf(__name__) === -1) {\r\n        values['__name__'].push(__name__);\r\n      }\r\n    }\r\n\r\n    Object.keys(rest).forEach(key => {\r\n      if (!values[key]) {\r\n        values[key] = [];\r\n      }\r\n      if (values[key].indexOf(rest[key]) === -1) {\r\n        values[key].push(rest[key]);\r\n      }\r\n    });\r\n  });\r\n  return { values, keys: Object.keys(values) };\r\n}\r\n\r\n// Strip syntax chars\r\nexport const cleanText = s => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\r\n\r\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\r\nconst selectorRegexp = /\\{[^}]*?\\}/;\r\nconst labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\r\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\r\n  if (!query.match(selectorRegexp)) {\r\n    // Special matcher for metrics\r\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\r\n      return {\r\n        selector: `{__name__=\"${query}\"}`,\r\n        labelKeys: ['__name__'],\r\n      };\r\n    }\r\n    throw new Error('Query must contain a selector: ' + query);\r\n  }\r\n\r\n  // Check if inside a selector\r\n  const prefix = query.slice(0, cursorOffset);\r\n  const prefixOpen = prefix.lastIndexOf('{');\r\n  const prefixClose = prefix.lastIndexOf('}');\r\n  if (prefixOpen === -1) {\r\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\r\n  }\r\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\r\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\r\n  }\r\n  const suffix = query.slice(cursorOffset);\r\n  const suffixCloseIndex = suffix.indexOf('}');\r\n  const suffixClose = suffixCloseIndex + cursorOffset;\r\n  const suffixOpenIndex = suffix.indexOf('{');\r\n  const suffixOpen = suffixOpenIndex + cursorOffset;\r\n  if (suffixClose === -1) {\r\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\r\n  }\r\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\r\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\r\n  }\r\n\r\n  // Extract clean labels to form clean selector, incomplete labels are dropped\r\n  const selector = query.slice(prefixOpen, suffixClose);\r\n  const labels = {};\r\n  selector.replace(labelRegexp, (_, key, operator, value) => {\r\n    labels[key] = { value, operator };\r\n    return '';\r\n  });\r\n\r\n  // Add metric if there is one before the selector\r\n  const metricPrefix = query.slice(0, prefixOpen);\r\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\r\n  if (metricMatch) {\r\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\r\n  }\r\n\r\n  // Build sorted selector\r\n  const labelKeys = Object.keys(labels).sort();\r\n  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');\r\n\r\n  const selectorString = ['{', cleanSelector, '}'].join('');\r\n\r\n  return { labelKeys, selector: selectorString };\r\n}\r\n","import { Query } from 'app/types/explore';\r\n\r\nexport function generateQueryKey(index = 0): string {\r\n  return `Q-${Date.now()}-${Math.random()}-${index}`;\r\n}\r\n\r\nexport function ensureQueries(queries?: Query[]): Query[] {\r\n  if (queries && typeof queries === 'object' && queries.length > 0 && typeof queries[0].query === 'string') {\r\n    return queries.map(({ query }, i) => ({ key: generateQueryKey(i), query }));\r\n  }\r\n  return [{ key: generateQueryKey(), query: '' }];\r\n}\r\n\r\nexport function hasQuery(queries: string[]): boolean {\r\n  return queries.some(q => Boolean(q));\r\n}\r\n"],"mappings":";;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/BA;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;;AAwBA;AAjCA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAaA;AAAA;AAQA;AAAA;AA2HA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuHA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AAhaA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAAA;;AAEA;;AAAA;;;AAEA;AACA;;AAAA;;AAEA;;AAAA;;;AAEA;;;;;;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AACA;AACA;AACA;AACA;AACA;;;;AAGA;;AAAA;AACA;;;;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AAGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;AAEA;AAoKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;;AAAA;AACA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAGA;;AAAA;AACA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAOA;AACA;AACA;AAIA;AAOA;AACA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AAKA;AAEA;AAcA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAKA;AACA;AACA;AAIA;AACA;;AACA;AAEA;AAIA;AAEA;AAIA;;AACA;AAAA;AAGA;AAEA;AAaA;AACA;AAKA;AAKA;AAOA;AACA;AACA;AACA;AAUA;AAEA;AAGA;AAMA;AACA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnpBA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAgBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAwBA;AACA;AAEA;AACA;AAGA;;AA2EA;AAxGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AAIA;AACA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;ACpMA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AALA;AAWA;AAAA;AAAA;;AAUA;AATA;AACA;AACA;AACA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAGA;AAQA;AAEA;AAAA;AAAA;;AAgCA;AA/BA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAWA;;AAEA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA8CA;AAAA;AAGA;AAAA;AAoCA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAmKA;AACA;AACA;AACA;AACA;AACA;AA/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AA0FA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AASA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AACA;AACA;;;AAAA;AAAA;AACA;AACA;;AAAA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAVA;;;AAYA;AACA;;;;AAEA;;;;;;AAEA;AAEA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AAIA;;;;AAEA;;;;;;AAEA;AAEA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AAIA;;;;AAEA;;;;;;AAEA;AAEA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AACA;;;;AAEA;;;;;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AAIA;AAIA;AACA;AACA;AAYA;AACA;AAEA;AAAA;AACA;AAUA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjmBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA+GA;AAAA;AAKA;AAAA;AA8CA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AACA;AAwCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AASA;AAxVA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AA+GA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA8JA;AACA;AAEA;AACA;AAaA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;ACjhBA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAiCA;AA/BA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AAAA;AAEA;AAAA;AAAA;;AAkBA;AAjBA;AACA;AACA;AAcA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AChGA;AACA;AACA;AAEA;AAEA;AAQA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA2BA;AAzBA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AAEA;AAYA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AA6DA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AA3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AA6DA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAeA;AACA;AAMA;AACA;AACA;AACA;AACA;AAIA;AAKA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAAA;AAEA;AACA;AAGA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;ACnPA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AAEA;AACA;AACA;;AAaA;AA3BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAUA;AAAA;AAAA;;AAsBA;AArBA;AACA;AACA;AAEA;AACA;AAEA;AASA;AAIA;AACA;AAAA;AASA;AAAA;AAAA;;AAWA;AAVA;AACA;AACA;AAOA;AACA;AAAA;AAEA;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AAEA;AACA;AAIA;AAcA;AACA;AAEA;AAAA;AAGA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AACA;AACA;AACA;AACA;;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AAcA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACvaA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}